diff --git a/camlp4/Camlp4/Struct/Camlp4Ast2OCamlAst.ml b/camlp4/Camlp4/Struct/Camlp4Ast2OCamlAst.ml
index 64492e2..efc0140 100644
--- a/camlp4/Camlp4/Struct/Camlp4Ast2OCamlAst.ml
+++ b/camlp4/Camlp4/Struct/Camlp4Ast2OCamlAst.ml
@@ -280,11 +280,11 @@ module Make (Ast : Sig.Camlp4Ast) = struct
         if is_cls then mktyp loc (Ptyp_class li (List.map ctyp al))
         else mktyp loc (Ptyp_constr li (List.map ctyp al))
     | TyArr loc (TyLab _ lab t1) t2 ->
-        mktyp loc (Ptyp_arrow lab (ctyp t1) (ctyp t2))
+        mktyp loc (Ptyp_arrow (Parr_labelled lab) (ctyp t1) (ctyp t2))
     | TyArr loc (TyOlb loc1 lab t1) t2 ->
         let t1 = TyApp loc1 (predef_option loc1) t1 in
-        mktyp loc (Ptyp_arrow ("?" ^ lab) (ctyp t1) (ctyp t2))
-    | TyArr loc t1 t2 -> mktyp loc (Ptyp_arrow "" (ctyp t1) (ctyp t2))
+        mktyp loc (Ptyp_arrow (Parr_optional lab) (ctyp t1) (ctyp t2))
+    | TyArr loc t1 t2 -> mktyp loc (Ptyp_arrow Parr_simple (ctyp t1) (ctyp t2))
     | <:ctyp@loc< < $fl$ > >> -> mktyp loc (Ptyp_object (meth_list fl []) Closed)
     | <:ctyp@loc< < $fl$ .. > >> ->
         mktyp loc (Ptyp_object (meth_list fl []) Open)
@@ -746,7 +746,7 @@ value varify_constructors var_names =
     fun
     [ <:expr@loc< $x$.val >> ->
         mkexp loc
-          (Pexp_apply (mkexp loc (Pexp_ident (lident_with_loc "!" loc))) [("", expr x)])
+          (Pexp_apply (mkexp loc (Pexp_ident (lident_with_loc "!" loc))) [(Papp_simple, expr x)])
     | ExAcc loc _ _ | <:expr@loc< $id:<:ident< $_$ . $_$ >>$ >> as e ->
         let (e, l) =
           match sep_expr_acc [] e with
@@ -792,7 +792,7 @@ value varify_constructors var_names =
     | ExAre loc e1 e2 ->
         mkexp loc
           (Pexp_apply (mkexp loc (Pexp_ident (array_function loc "Array" "get")))
-            [("", expr e1); ("", expr e2)])
+            [(Papp_simple, expr e1); (Papp_simple, expr e2)])
     | ExArr loc e -> mkexp loc (Pexp_array (List.map expr (list_of_expr e [])))
     | ExAsf loc ->
         mkexp loc (Pexp_assert (mkexp loc (Pexp_construct {txt=Lident "false"; loc=mkloc loc} None)))
@@ -801,19 +801,19 @@ value varify_constructors var_names =
           match e with
           [ <:expr@loc< $x$.val >> ->
               Pexp_apply (mkexp loc (Pexp_ident (lident_with_loc ":=" loc)))
-                [("", expr x); ("", expr v)]
+                [(Papp_simple, expr x); (Papp_simple, expr v)]
           | ExAcc loc _ _ ->
               match (expr e).pexp_desc with
               [ Pexp_field e lab -> Pexp_setfield e lab (expr v)
               | _ -> error loc "bad record access" ]
           | ExAre loc e1 e2 ->
               Pexp_apply (mkexp loc (Pexp_ident (array_function loc "Array" "set")))
-                [("", expr e1); ("", expr e2); ("", expr v)]
+                [(Papp_simple, expr e1); (Papp_simple, expr e2); (Papp_simple, expr v)]
           | <:expr< $id:(<:ident@lloc< $lid:lab$ >>)$ >> -> Pexp_setinstvar (with_loc lab lloc) (expr v)
           | ExSte loc e1 e2 ->
               Pexp_apply
                 (mkexp loc (Pexp_ident (array_function loc "String" "set")))
-                [("", expr e1); ("", expr e2); ("", expr v)]
+                [(Papp_simple, expr e1); (Papp_simple, expr e2); (Papp_simple, expr v)]
           | _ -> error loc "bad left part of assignment" ]
         in
         mkexp loc e
@@ -831,13 +831,13 @@ value varify_constructors var_names =
         let e3 = ExSeq loc el in
         mkexp loc (Pexp_for (patt p) (expr e1) (expr e2) (mkdirection df) (expr e3))
     | <:expr@loc< fun [ $PaLab _ lab po$ when $w$ -> $e$ ] >> ->
-        mkfun loc lab None (patt_of_lab loc lab po) e w
+        mkfun loc (Parr_labelled lab) None (patt_of_lab loc lab po) e w
     | <:expr@loc< fun [ $PaOlbi _ lab p e1$ when $w$ -> $e2$ ] >> ->
         let lab = paolab lab p in
-        mkfun loc ("?" ^ lab) (Some (expr e1)) (patt p) e2 w
+        mkfun loc (Parr_optional lab) (Some (expr e1)) (patt p) e2 w
     | <:expr@loc< fun [ $PaOlb _ lab p$ when $w$ -> $e$ ] >> ->
         let lab = paolab lab p in
-        mkfun loc ("?" ^ lab) None (patt_of_lab loc lab p) e w
+        mkfun loc (Parr_optional lab) None (patt_of_lab loc lab p) e w
     | ExFun loc a -> mkexp loc (Pexp_function (match_case a []))
     | ExIfe loc e1 e2 e3 ->
         mkexp loc (Pexp_ifthenelse (expr e1) (expr e2) (Some (expr e3)))
@@ -861,7 +861,9 @@ value varify_constructors var_names =
     | ExLaz loc e -> mkexp loc (Pexp_lazy (expr e))
     | ExLet loc rf bi e ->
         mkexp loc (Pexp_let (mkrf rf) (binding bi []) (expr e))
-    | ExLmd loc i me e -> mkexp loc (Pexp_letmodule (with_loc i loc) (module_expr me) (expr e))
+    | ExLmd loc i me e ->
+      let mb = {pmb_loc=mkloc loc; pmb_name=with_loc i loc;pmb_expr=module_expr me;pmb_attributes=[]; pmb_implicit = Nonimplicit} in
+      mkexp loc (Pexp_letmodule (mb, (expr e)))
     | ExMat loc e a -> mkexp loc (Pexp_match (expr e) (match_case a []))
     | ExNew loc id -> mkexp loc (Pexp_new (long_type_ident id))
     | ExObj loc po cfl ->
@@ -897,7 +899,7 @@ value varify_constructors var_names =
     | ExSte loc e1 e2 ->
         mkexp loc
           (Pexp_apply (mkexp loc (Pexp_ident (array_function loc "String" "get")))
-            [("", expr e1); ("", expr e2)])
+            [(Papp_simple, expr e1); (Papp_simple, expr e2)])
     | ExStr loc s ->
         mkexp loc (Pexp_constant (Const_string (string_of_string_token loc s) None))
     | ExTry loc e a -> mkexp loc (Pexp_try (expr e) (match_case a []))
@@ -917,7 +919,7 @@ value varify_constructors var_names =
         mkexp loc (Pexp_while (expr e1) (expr e2))
     | ExOpI loc i ov e ->
         let fresh = override_flag loc ov in
-        mkexp loc (Pexp_open fresh (long_uident i) (expr e))
+        mkexp loc (Pexp_open (Open_all fresh) (long_uident i) (expr e))
     | <:expr@loc< (module $me$ : $pt$) >> ->
         mkexp loc (Pexp_constraint (mkexp loc (Pexp_pack (module_expr me)),
                     mktyp loc (Ptyp_package (package_type pt))))
@@ -942,9 +944,9 @@ value varify_constructors var_names =
     | e -> expr e ]
   and label_expr =
     fun
-    [ ExLab loc lab eo -> (lab, expr_of_lab loc lab eo)
-    | ExOlb loc lab eo -> ("?" ^ lab, expr_of_lab loc lab eo)
-    | e -> ("", expr e) ]
+    [ ExLab loc lab eo -> (Papp_labelled lab, expr_of_lab loc lab eo)
+    | ExOlb loc lab eo -> (Papp_optional lab, expr_of_lab loc lab eo)
+    | e -> (Papp_simple, expr e) ]
   and binding x acc =
     match x with
     [ <:binding< $x$ and $y$ >> ->
@@ -1081,7 +1083,8 @@ value varify_constructors var_names =
     | SgInc loc mt -> [mksig loc (Psig_include {pincl_mod=module_type mt;
                                                 pincl_attributes=[];
                                                 pincl_loc = mkloc loc}) :: l]
-    | SgMod loc n mt -> [mksig loc (Psig_module {pmd_loc=mkloc loc; pmd_name=with_loc n loc; pmd_type=module_type mt; pmd_attributes=[]}) :: l]
+    | SgMod loc n mt -> [mksig loc (Psig_module {
+       pmd_implicit = Nonimplicit; pmd_loc=mkloc loc; pmd_name=with_loc n loc; pmd_type=module_type mt; pmd_attributes=[]}) :: l]
     | SgRecMod loc mb ->
         [mksig loc (Psig_recmodule (module_sig_binding mb [])) :: l]
     | SgMty loc n mt ->
@@ -1092,8 +1095,8 @@ value varify_constructors var_names =
         in
         [mksig loc (Psig_modtype {pmtd_loc=mkloc loc; pmtd_name=with_loc n loc; pmtd_type=si; pmtd_attributes=[]}) :: l]
     | SgOpn loc ov id ->
-        let fresh = override_flag loc ov in
-        [mksig loc (Psig_open {popen_override=fresh; popen_lid=long_uident id;
+        let fresh = Open_all (override_flag loc ov) in
+        [mksig loc (Psig_open {popen_flag=fresh; popen_lid=long_uident id;
                                popen_attributes=[]; popen_loc = mkloc loc}) :: l]
     | SgTyp loc tdl -> [mksig loc (Psig_type (mktype_decl tdl [])) :: l]
     | SgVal loc n t -> [mksig loc (Psig_value (mkvalue_desc loc (with_loc n loc) t [])) :: l]
@@ -1103,7 +1106,7 @@ value varify_constructors var_names =
     [ <:module_binding< $x$ and $y$ >> ->
         module_sig_binding x (module_sig_binding y acc)
     | <:module_binding@loc< $s$ : $mt$ >> ->
-        [{pmd_loc=mkloc loc; pmd_name=with_loc s loc; pmd_type=module_type mt; pmd_attributes=[]} :: acc]
+        [{pmd_implicit = Nonimplicit;pmd_loc=mkloc loc; pmd_name=with_loc s loc; pmd_type=module_type mt; pmd_attributes=[]} :: acc]
     | _ -> assert False ]
   and module_str_binding x acc =
     match x with
@@ -1117,6 +1120,7 @@ value varify_constructors var_names =
            pmod_desc=Pmod_constraint(module_expr me,module_type mt);
            pmod_attributes=[];
           };
+          pmb_implicit = Nonimplicit;
           pmb_attributes=[]} :: acc]
     | _ -> assert False ]
   and module_expr =
@@ -1180,7 +1184,9 @@ value varify_constructors var_names =
     | StInc loc me -> [mkstr loc (Pstr_include {pincl_mod=module_expr me;
                                                 pincl_attributes=[];
                                                 pincl_loc=mkloc loc}) :: l]
-    | StMod loc n me -> [mkstr loc (Pstr_module {pmb_loc=mkloc loc; pmb_name=with_loc n loc;pmb_expr=module_expr me;pmb_attributes=[]}) :: l]
+    | StMod loc n me -> [mkstr loc (Pstr_module {
+        pmb_implicit = Nonimplicit; pmb_loc=mkloc loc;
+        pmb_name=with_loc n loc;pmb_expr=module_expr me;pmb_attributes=[]}) :: l]
     | StRecMod loc mb ->
         [mkstr loc (Pstr_recmodule (module_str_binding mb [])) :: l]
     | StMty loc n mt ->
@@ -1192,7 +1198,7 @@ value varify_constructors var_names =
         [mkstr loc (Pstr_modtype {pmtd_loc=mkloc loc; pmtd_name=with_loc n loc; pmtd_type=si; pmtd_attributes=[]}) :: l]
     | StOpn loc ov id ->
         let fresh = override_flag loc ov in
-        [mkstr loc (Pstr_open {popen_override=fresh;
+        [mkstr loc (Pstr_open {popen_flag=Open_all fresh;
                                popen_lid=long_uident id;
                                popen_attributes=[];
                                popen_loc=mkloc loc}) :: l]
@@ -1206,11 +1212,11 @@ value varify_constructors var_names =
         mkcty loc
           (Pcty_constr (long_class_ident id) (List.map ctyp (list_of_opt_ctyp tl [])))
     | CtFun loc (TyLab _ lab t) ct ->
-        mkcty loc (Pcty_arrow lab (ctyp t) (class_type ct))
+        mkcty loc (Pcty_arrow (Parr_labelled lab) (ctyp t) (class_type ct))
     | CtFun loc (TyOlb loc1 lab t) ct ->
         let t = TyApp loc1 (predef_option loc1) t in
-        mkcty loc (Pcty_arrow ("?" ^ lab) (ctyp t) (class_type ct))
-    | CtFun loc t ct -> mkcty loc (Pcty_arrow "" (ctyp t) (class_type ct))
+        mkcty loc (Pcty_arrow (Parr_optional lab) (ctyp t) (class_type ct))
+    | CtFun loc t ct -> mkcty loc (Pcty_arrow Parr_simple (ctyp t) (class_type ct))
     | CtSig loc t_o ctfl ->
         let t =
           match t_o with
@@ -1289,15 +1295,15 @@ value varify_constructors var_names =
           (Pcl_constr (long_class_ident id) (List.map ctyp (list_of_opt_ctyp tl [])))
     | CeFun loc (PaLab _ lab po) ce ->
         mkcl loc
-          (Pcl_fun lab None (patt_of_lab loc lab po) (class_expr ce))
+          (Pcl_fun (Parr_labelled lab) None (patt_of_lab loc lab po) (class_expr ce))
     | CeFun loc (PaOlbi _ lab p e) ce ->
         let lab = paolab lab p in
-        mkcl loc (Pcl_fun ("?" ^ lab) (Some (expr e)) (patt p) (class_expr ce))
+        mkcl loc (Pcl_fun (Parr_optional lab) (Some (expr e)) (patt p) (class_expr ce))
     | CeFun loc (PaOlb _ lab p) ce ->
         let lab = paolab lab p in
         mkcl loc
-          (Pcl_fun ("?" ^ lab) None (patt_of_lab loc lab p) (class_expr ce))
-    | CeFun loc p ce -> mkcl loc (Pcl_fun "" None (patt p) (class_expr ce))
+          (Pcl_fun (Parr_optional lab) None (patt_of_lab loc lab p) (class_expr ce))
+    | CeFun loc p ce -> mkcl loc (Pcl_fun Parr_simple None (patt p) (class_expr ce))
     | CeLet loc rf bi ce ->
         mkcl loc (Pcl_let (mkrf rf) (binding bi []) (class_expr ce))
     | CeStr loc po cfl ->
diff --git a/camlp4/Camlp4Top/Rprint.ml b/camlp4/Camlp4Top/Rprint.ml
index 57f319d..8238e9f 100644
--- a/camlp4/Camlp4Top/Rprint.ml
+++ b/camlp4/Camlp4Top/Rprint.ml
@@ -208,6 +208,7 @@ and print_simple_out_type ppf =
             n tyl;
           fprintf ppf ")@]"
       }
+  | Otyp_implicit_arrow _ -> failwith "TODO"
   | Otyp_alias _ _ | Otyp_poly _ _ | Otyp_open
   | Otyp_arrow _ _ _ | Otyp_constr _ [_ :: _] as ty ->
       fprintf ppf "@[<1>(%a)@]" print_out_type ty ]
@@ -364,7 +365,7 @@ and needs_semi =
   fun
   [ Osig_class _ _ _ _ rs
   | Osig_class_type _ _ _ _ rs
-  | Osig_module _ _ rs
+  | Osig_module _ _ rs _
   | Osig_type _ rs -> rs <> Orec_next
   | Osig_typext _ _
   | Osig_modtype _ _
@@ -401,9 +402,9 @@ and print_out_sig_item ppf =
   | Osig_modtype name mty ->
       fprintf ppf "@[<2>module type %s =@ %a@]" name
         Toploop.print_out_module_type.val mty
-  | Osig_module name (Omty_alias id) Orec_not ->
+  | Osig_module name (Omty_alias id) Orec_not _ ->
       fprintf ppf "@[<2>module %s :@ %a@]" name print_ident id
-  | Osig_module name mty rs ->
+  | Osig_module name mty rs _ ->
       fprintf ppf "@[<2>%s %s :@ %a@]"
         (match rs with [ Orec_not -> "module"
                        | Orec_first -> "module rec"
diff --git a/camlp4/boot/Camlp4.ml b/camlp4/boot/Camlp4.ml
index 49823da..889a146 100644
--- a/camlp4/boot/Camlp4.ml
+++ b/camlp4/boot/Camlp4.ml
@@ -1,3 +1,13 @@
+let parr = function
+  | "" -> Parsetree.Parr_simple
+  | s when s.[0] = '?' -> Parr_optional (String.sub s 1 (String.length s - 1))
+  | s  -> Parsetree.Parr_labelled s
+
+let papp = function
+  | "" -> Parsetree.Papp_simple
+  | s when s.[0] = '?' -> Papp_optional (String.sub s 1 (String.length s - 1))
+  | s  -> Parsetree.Papp_labelled s
+
 module Utils : sig val float_repres : float -> string
                       end =
   struct
@@ -9,7 +19,7 @@ module Utils : sig val float_repres : float -> string
         then s ^ "."
         else (match s.[i] with | '0' .. '9' | '-' -> loop (i + 1) | _ -> s)
       in loop 0
-      
+
     let float_repres f =
       match classify_float f with
       | FP_nan -> "nan"
@@ -27,9 +37,9 @@ module Utils : sig val float_repres : float -> string
                    then s2
                    else Printf.sprintf "%.18g" f)
           in valid_float_lexeme float_val
-      
+
   end
-  
+
 module Debug :
   sig
     (****************************************************************************)
@@ -51,11 +61,11 @@ module Debug :
  *)
     (* camlp4r *)
     type section = string
-    
+
     val mode : section -> bool
-      
+
     val printf : section -> ('a, Format.formatter, unit) format -> 'a
-      
+
   end =
   struct
     (****************************************************************************)
@@ -77,12 +87,12 @@ module Debug :
  *)
     (* camlp4r *)
     open Format
-      
+
     module Debug = struct let mode _ = false
                              end
-      
+
     type section = string
-    
+
     let out_channel =
       try
         let f = Sys.getenv "CAMLP4_DEBUG_FILE"
@@ -90,9 +100,9 @@ module Debug :
           open_out_gen [ Open_wronly; Open_creat; Open_append; Open_text ]
             0o666 f
       with | Not_found -> Pervasives.stderr
-      
+
     module StringSet = Set.Make(String)
-      
+
     let mode =
       try
         let str = Sys.getenv "CAMLP4_DEBUG" in
@@ -110,7 +120,7 @@ module Debug :
           then (fun _ -> true)
           else (fun x -> StringSet.mem x sections)
       with | Not_found -> (fun _ -> false)
-      
+
     let formatter =
       let header = "camlp4-debug: " in
       let at_bol = ref true
@@ -123,11 +133,11 @@ module Debug :
                in (output_char out_channel ch; at_bol := ch = '\n')
              done)
           (fun () -> flush out_channel)
-      
+
     let printf section fmt = fprintf formatter ("%s: " ^^ fmt) section
-      
+
   end
-  
+
 module Options :
   sig
     (****************************************************************************)
@@ -148,18 +158,18 @@ module Options :
  * - Nicolas Pouillard: refactoring
  *)
     type spec_list = (string * Arg.spec * string) list
-    
+
     val init : spec_list -> unit
-      
+
     val add : string -> Arg.spec -> string -> unit
-      
+
     (** Add an option to the command line options. *)
     val print_usage_list : spec_list -> unit
-      
+
     val ext_spec_list : unit -> spec_list
-      
+
     val parse : (string -> unit) -> string array -> string list
-      
+
   end =
   struct
     (****************************************************************************)
@@ -180,9 +190,9 @@ module Options :
  * - Nicolas Pouillard: refactoring
  *)
     type spec_list = (string * Arg.spec * string) list
-    
+
     open Format
-      
+
     let rec action_arg s sl =
       function
       | Arg.Unit f -> if s = "" then (f (); Some sl) else None
@@ -258,14 +268,14 @@ module Options :
           (match if s = "" then sl else s :: sl with
            | s :: sl when List.mem s syms -> (f s; Some sl)
            | _ -> None)
-      
+
     let common_start s1 s2 =
       let rec loop i =
         if (i == (String.length s1)) || (i == (String.length s2))
         then i
         else if s1.[i] == s2.[i] then loop (i + 1) else i
       in loop 0
-      
+
     let parse_arg fold s sl =
       fold
         (fun (name, action, _) acu ->
@@ -279,7 +289,7 @@ module Options :
                 with | Arg.Bad _ -> acu)
              else acu)
         None
-      
+
     let rec parse_aux fold anon_fun =
       function
       | [] -> []
@@ -290,7 +300,7 @@ module Options :
              | Some sl -> parse_aux fold anon_fun sl
              | None -> s :: (parse_aux fold anon_fun sl))
           else ((anon_fun s : unit); parse_aux fold anon_fun sl)
-      
+
     let align_doc key s =
       let s =
         let rec loop i =
@@ -329,13 +339,13 @@ module Options :
         String.make (max 1 ((16 - (String.length key)) - (String.length p)))
           ' '
       in p ^ (tab ^ s)
-      
+
     let make_symlist l =
       match l with
       | [] -> "<none>"
       | h :: t ->
           (List.fold_left (fun x y -> x ^ ("|" ^ y)) ("{" ^ h) t) ^ "}"
-      
+
     let print_usage_list l =
       List.iter
         (fun (key, spec, doc) ->
@@ -346,34 +356,34 @@ module Options :
                in eprintf "  %s %s\n" synt (align_doc synt doc)
            | _ -> eprintf "  %s %s\n" key (align_doc key doc))
         l
-      
+
     let remaining_args argv =
       let rec loop l i =
         if i == (Array.length argv) then l else loop (argv.(i) :: l) (i + 1)
       in List.rev (loop [] (!Arg.current + 1))
-      
+
     let init_spec_list = ref []
-      
+
     let ext_spec_list = ref []
-      
+
     let init spec_list = init_spec_list := spec_list
-      
+
     let add name spec descr =
       ext_spec_list := (name, spec, descr) :: !ext_spec_list
-      
+
     let fold f init =
       let spec_list = !init_spec_list @ !ext_spec_list in
       let specs = Sort.list (fun (k1, _, _) (k2, _, _) -> k1 >= k2) spec_list
       in List.fold_right f specs init
-      
+
     let parse anon_fun argv =
       let remaining_args = remaining_args argv
       in parse_aux fold anon_fun remaining_args
-      
+
     let ext_spec_list () = !ext_spec_list
-      
+
   end
-  
+
 module Sig =
   struct
     (* camlp4r *)
@@ -399,49 +409,49 @@ module Sig =
     (** Signature with just a type. *)
     module type Type = sig type t
                             end
-      
+
     (** Signature for errors modules, an Error modules can be registred with
     the {!ErrorHandler.Register} functor in order to be well printed. *)
     module type Error =
       sig
         type t
-        
+
         exception E of t
-          
+
         val to_string : t -> string
-          
+
         val print : Format.formatter -> t -> unit
-          
+
       end
-      
+
     (** A signature for extensions identifiers. *)
     module type Id =
       sig
         (** The name of the extension, typically the module name. *)
         val name : string
-          
+
         (** The version of the extension, typically $ Id$ with a versionning system. *)
         val version : string
-          
+
       end
-      
+
     (** A signature for warnings abstract from locations. *)
     module Warning (Loc : Type) =
       struct
         module type S =
           sig
             type warning = Loc.t -> string -> unit
-            
+
             val default_warning : warning
-              
+
             val current_warning : warning ref
-              
+
             val print_warning : warning
-              
+
           end
-          
+
       end
-      
+
     (** {6 Advanced signatures} *)
     (** A signature for locations. *)
     module type Loc =
@@ -457,136 +467,136 @@ module Sig =
       to use character numbers with the source file if the sources
       contain line number directives. *)
         type t
-        
+
         (** Return a start location for the given file name.
       This location starts at the begining of the file. *)
         val mk : string -> t
-          
+
         (** The [ghost] location can be used when no location
       information is available. *)
         val ghost : t
-          
+
         (** {6 Conversion functions} *)
         (** Return a location where both positions are set the given position. *)
         val of_lexing_position : Lexing.position -> t
-          
+
         (** Return an OCaml location. *)
         val to_ocaml_location : t -> Location.t
-          
+
         (** Return a location from an OCaml location. *)
         val of_ocaml_location : Location.t -> t
-          
+
         (** Return a location from ocamllex buffer. *)
         val of_lexbuf : Lexing.lexbuf -> t
-          
+
         (** Return a location from [(file_name, start_line, start_bol, start_off,
       stop_line,  stop_bol,  stop_off, ghost)]. *)
         val of_tuple :
           (string * int * int * int * int * int * int * bool) -> t
-          
+
         (** Return [(file_name, start_line, start_bol, start_off,
       stop_line,  stop_bol,  stop_off, ghost)]. *)
         val to_tuple :
           t -> (string * int * int * int * int * int * int * bool)
-          
+
         (** [merge loc1 loc2] Return a location that starts at [loc1] and end at
       [loc2]. *)
         val merge : t -> t -> t
-          
+
         (** The stop pos becomes equal to the start pos. *)
         val join : t -> t
-          
+
         (** [move selector n loc]
       Return the location where positions are moved.
       Affected positions are chosen with [selector].
       Returned positions have their character offset plus [n]. *)
         val move : [ | `start | `stop | `both ] -> int -> t -> t
-          
+
         (** [shift n loc] Return the location where the new start position is the old
       stop position, and where the new stop position character offset is the
       old one plus [n]. *)
         val shift : int -> t -> t
-          
+
         (** [move_line n loc] Return the location with the old line count plus [n].
       The "begin of line" of both positions become the current offset. *)
         val move_line : int -> t -> t
-          
+
         (** {6 Accessors} *)
         (** Return the file name *)
         val file_name : t -> string
-          
+
         (** Return the line number of the begining of this location. *)
         val start_line : t -> int
-          
+
         (** Return the line number of the ending of this location. *)
         val stop_line : t -> int
-          
+
         (** Returns the number of characters from the begining of the stream
       to the begining of the line of location's begining. *)
         val start_bol : t -> int
-          
+
         (** Returns the number of characters from the begining of the stream
       to the begining of the line of location's ending. *)
         val stop_bol : t -> int
-          
+
         (** Returns the number of characters from the begining of the stream
       of the begining of this location. *)
         val start_off : t -> int
-          
+
         (** Return the number of characters from the begining of the stream
       of the ending of this location. *)
         val stop_off : t -> int
-          
+
         (** Return the start position as a Lexing.position. *)
         val start_pos : t -> Lexing.position
-          
+
         (** Return the stop position as a Lexing.position. *)
         val stop_pos : t -> Lexing.position
-          
+
         (** Generally, return true if this location does not come
       from an input stream. *)
         val is_ghost : t -> bool
-          
+
         (** Return the associated ghost location. *)
         val ghostify : t -> t
-          
+
         (** Return the location with the give file name *)
         val set_file_name : string -> t -> t
-          
+
         (** [strictly_before loc1 loc2] True if the stop position of [loc1] is
       strictly_before the start position of [loc2]. *)
         val strictly_before : t -> t -> bool
-          
+
         (** Return the location with an absolute file name. *)
         val make_absolute : t -> t
-          
+
         (** Print the location into the formatter in a format suitable for error
       reporting. *)
         val print : Format.formatter -> t -> unit
-          
+
         (** Print the location in a short format useful for debugging. *)
         val dump : Format.formatter -> t -> unit
-          
+
         (** Same as {!print} but return a string instead of printting it. *)
         val to_string : t -> string
-          
+
         (** [Exc_located loc e] is an encapsulation of the exception [e] with
       the input location [loc]. To be used in quotation expanders
       and in grammars to specify some input location for an error.
       Do not raise this exception directly: rather use the following
       function [Loc.raise]. *)
         exception Exc_located of t * exn
-          
+
         (** [raise loc e], if [e] is already an [Exc_located] exception,
       re-raise it, else raise the exception [Exc_located loc e]. *)
         val raise : t -> exn -> 'a
-          
+
         (** The name of the location variable used in grammars and in
       the predefined quotations for OCaml syntax trees. Default: [_loc]. *)
         val name : string ref
-          
+
       end
-      
+
     (** Abstract syntax tree minimal signature.
     Types of this signature are abstract.
     See the {!Camlp4Ast} signature for a concrete definition. *)
@@ -594,96 +604,96 @@ module Sig =
       sig
         (** {6 Syntactic categories as abstract types} *)
         type loc
-        
+
         type meta_bool
-        
+
         type 'a meta_option
-        
+
         type 'a meta_list
-        
+
         type ctyp
-        
+
         type patt
-        
+
         type expr
-        
+
         type module_type
-        
+
         type sig_item
-        
+
         type with_constr
-        
+
         type module_expr
-        
+
         type str_item
-        
+
         type class_type
-        
+
         type class_sig_item
-        
+
         type class_expr
-        
+
         type class_str_item
-        
+
         type match_case
-        
+
         type ident
-        
+
         type binding
-        
+
         type rec_binding
-        
+
         type module_binding
-        
+
         type rec_flag
-        
+
         type direction_flag
-        
+
         type mutable_flag
-        
+
         type private_flag
-        
+
         type virtual_flag
-        
+
         type row_var_flag
-        
+
         type override_flag
-        
+
         (** {6 Location accessors} *)
         val loc_of_ctyp : ctyp -> loc
-          
+
         val loc_of_patt : patt -> loc
-          
+
         val loc_of_expr : expr -> loc
-          
+
         val loc_of_module_type : module_type -> loc
-          
+
         val loc_of_module_expr : module_expr -> loc
-          
+
         val loc_of_sig_item : sig_item -> loc
-          
+
         val loc_of_str_item : str_item -> loc
-          
+
         val loc_of_class_type : class_type -> loc
-          
+
         val loc_of_class_sig_item : class_sig_item -> loc
-          
+
         val loc_of_class_expr : class_expr -> loc
-          
+
         val loc_of_class_str_item : class_str_item -> loc
-          
+
         val loc_of_with_constr : with_constr -> loc
-          
+
         val loc_of_binding : binding -> loc
-          
+
         val loc_of_rec_binding : rec_binding -> loc
-          
+
         val loc_of_module_binding : module_binding -> loc
-          
+
         val loc_of_match_case : match_case -> loc
-          
+
         val loc_of_ident : ident -> loc
-          
+
         (** {6 Traversals} *)
         (** This class is the base class for map traversal on the Ast.
       To make a custom traversal class one just extend it like that:
@@ -739,7 +749,7 @@ module Sig =
             method row_var_flag : row_var_flag -> row_var_flag
             method unknown : 'a. 'a -> 'a
           end
-          
+
         (** Fold style traversal *)
         class fold :
           object ('self_type)
@@ -782,9 +792,9 @@ module Sig =
             method override_flag : override_flag -> 'self_type
             method unknown : 'a. 'a -> 'self_type
           end
-          
+
       end
-      
+
     (** Signature for OCaml syntax trees. *)
     (*
     This signature is an extension of {!Ast}
@@ -820,7 +830,7 @@ module Sig =
       sig
         (** The inner module for locations *)
         module Loc : Loc
-          
+
         (****************************************************************************)
         (*                                                                          *)
         (*                                   OCaml                                  *)
@@ -1340,211 +1350,211 @@ module Sig =
           | (* value virtual (mutable)? s : t *)
           CrVvr of loc * string * mutable_flag * ctyp
           | CrAnt of loc * string
-        
+
         val loc_of_ctyp : ctyp -> loc
-          
+
         val loc_of_patt : patt -> loc
-          
+
         val loc_of_expr : expr -> loc
-          
+
         val loc_of_module_type : module_type -> loc
-          
+
         val loc_of_module_expr : module_expr -> loc
-          
+
         val loc_of_sig_item : sig_item -> loc
-          
+
         val loc_of_str_item : str_item -> loc
-          
+
         val loc_of_class_type : class_type -> loc
-          
+
         val loc_of_class_sig_item : class_sig_item -> loc
-          
+
         val loc_of_class_expr : class_expr -> loc
-          
+
         val loc_of_class_str_item : class_str_item -> loc
-          
+
         val loc_of_with_constr : with_constr -> loc
-          
+
         val loc_of_binding : binding -> loc
-          
+
         val loc_of_rec_binding : rec_binding -> loc
-          
+
         val loc_of_module_binding : module_binding -> loc
-          
+
         val loc_of_match_case : match_case -> loc
-          
+
         val loc_of_ident : ident -> loc
-          
+
         module Meta :
           sig
             module type META_LOC =
               sig
                 val meta_loc_patt : loc -> loc -> patt
-                  
+
                 val meta_loc_expr : loc -> loc -> expr
-                  
+
               end
-              
+
             module MetaLoc :
               sig
                 val meta_loc_patt : loc -> loc -> patt
-                  
+
                 val meta_loc_expr : loc -> loc -> expr
-                  
+
               end
-              
+
             module MetaGhostLoc :
               sig
                 val meta_loc_patt : loc -> 'a -> patt
-                  
+
                 val meta_loc_expr : loc -> 'a -> expr
-                  
+
               end
-              
+
             module MetaLocVar :
               sig
                 val meta_loc_patt : loc -> 'a -> patt
-                  
+
                 val meta_loc_expr : loc -> 'a -> expr
-                  
+
               end
-              
+
             module Make (MetaLoc : META_LOC) :
               sig
                 module Expr :
                   sig
                     val meta_string : loc -> string -> expr
-                      
+
                     val meta_int : loc -> string -> expr
-                      
+
                     val meta_float : loc -> string -> expr
-                      
+
                     val meta_char : loc -> string -> expr
-                      
+
                     val meta_bool : loc -> bool -> expr
-                      
+
                     val meta_list :
                       (loc -> 'a -> expr) -> loc -> 'a list -> expr
-                      
+
                     val meta_binding : loc -> binding -> expr
-                      
+
                     val meta_rec_binding : loc -> rec_binding -> expr
-                      
+
                     val meta_class_expr : loc -> class_expr -> expr
-                      
+
                     val meta_class_sig_item : loc -> class_sig_item -> expr
-                      
+
                     val meta_class_str_item : loc -> class_str_item -> expr
-                      
+
                     val meta_class_type : loc -> class_type -> expr
-                      
+
                     val meta_ctyp : loc -> ctyp -> expr
-                      
+
                     val meta_expr : loc -> expr -> expr
-                      
+
                     val meta_ident : loc -> ident -> expr
-                      
+
                     val meta_match_case : loc -> match_case -> expr
-                      
+
                     val meta_module_binding : loc -> module_binding -> expr
-                      
+
                     val meta_module_expr : loc -> module_expr -> expr
-                      
+
                     val meta_module_type : loc -> module_type -> expr
-                      
+
                     val meta_patt : loc -> patt -> expr
-                      
+
                     val meta_sig_item : loc -> sig_item -> expr
-                      
+
                     val meta_str_item : loc -> str_item -> expr
-                      
+
                     val meta_with_constr : loc -> with_constr -> expr
-                      
+
                     val meta_rec_flag : loc -> rec_flag -> expr
-                      
+
                     val meta_mutable_flag : loc -> mutable_flag -> expr
-                      
+
                     val meta_virtual_flag : loc -> virtual_flag -> expr
-                      
+
                     val meta_private_flag : loc -> private_flag -> expr
-                      
+
                     val meta_row_var_flag : loc -> row_var_flag -> expr
-                      
+
                     val meta_override_flag : loc -> override_flag -> expr
-                      
+
                     val meta_direction_flag : loc -> direction_flag -> expr
-                      
+
                   end
-                  
+
                 module Patt :
                   sig
                     val meta_string : loc -> string -> patt
-                      
+
                     val meta_int : loc -> string -> patt
-                      
+
                     val meta_float : loc -> string -> patt
-                      
+
                     val meta_char : loc -> string -> patt
-                      
+
                     val meta_bool : loc -> bool -> patt
-                      
+
                     val meta_list :
                       (loc -> 'a -> patt) -> loc -> 'a list -> patt
-                      
+
                     val meta_binding : loc -> binding -> patt
-                      
+
                     val meta_rec_binding : loc -> rec_binding -> patt
-                      
+
                     val meta_class_expr : loc -> class_expr -> patt
-                      
+
                     val meta_class_sig_item : loc -> class_sig_item -> patt
-                      
+
                     val meta_class_str_item : loc -> class_str_item -> patt
-                      
+
                     val meta_class_type : loc -> class_type -> patt
-                      
+
                     val meta_ctyp : loc -> ctyp -> patt
-                      
+
                     val meta_expr : loc -> expr -> patt
-                      
+
                     val meta_ident : loc -> ident -> patt
-                      
+
                     val meta_match_case : loc -> match_case -> patt
-                      
+
                     val meta_module_binding : loc -> module_binding -> patt
-                      
+
                     val meta_module_expr : loc -> module_expr -> patt
-                      
+
                     val meta_module_type : loc -> module_type -> patt
-                      
+
                     val meta_patt : loc -> patt -> patt
-                      
+
                     val meta_sig_item : loc -> sig_item -> patt
-                      
+
                     val meta_str_item : loc -> str_item -> patt
-                      
+
                     val meta_with_constr : loc -> with_constr -> patt
-                      
+
                     val meta_rec_flag : loc -> rec_flag -> patt
-                      
+
                     val meta_mutable_flag : loc -> mutable_flag -> patt
-                      
+
                     val meta_virtual_flag : loc -> virtual_flag -> patt
-                      
+
                     val meta_private_flag : loc -> private_flag -> patt
-                      
+
                     val meta_row_var_flag : loc -> row_var_flag -> patt
-                      
+
                     val meta_override_flag : loc -> override_flag -> patt
-                      
+
                     val meta_direction_flag : loc -> direction_flag -> patt
-                      
+
                   end
-                  
+
               end
-              
+
           end
-          
+
         class map :
           object ('self_type)
             method string : string -> string
@@ -1583,7 +1593,7 @@ module Sig =
             method override_flag : override_flag -> override_flag
             method unknown : 'a. 'a -> 'a
           end
-          
+
         class fold :
           object ('self_type)
             method string : string -> 'self_type
@@ -1625,140 +1635,140 @@ module Sig =
             method override_flag : override_flag -> 'self_type
             method unknown : 'a. 'a -> 'self_type
           end
-          
+
         val map_expr : (expr -> expr) -> map
-          
+
         val map_patt : (patt -> patt) -> map
-          
+
         val map_ctyp : (ctyp -> ctyp) -> map
-          
+
         val map_str_item : (str_item -> str_item) -> map
-          
+
         val map_sig_item : (sig_item -> sig_item) -> map
-          
+
         val map_loc : (loc -> loc) -> map
-          
+
         val ident_of_expr : expr -> ident
-          
+
         val ident_of_patt : patt -> ident
-          
+
         val ident_of_ctyp : ctyp -> ident
-          
+
         val biAnd_of_list : binding list -> binding
-          
+
         val rbSem_of_list : rec_binding list -> rec_binding
-          
+
         val paSem_of_list : patt list -> patt
-          
+
         val paCom_of_list : patt list -> patt
-          
+
         val tyOr_of_list : ctyp list -> ctyp
-          
+
         val tyAnd_of_list : ctyp list -> ctyp
-          
+
         val tyAmp_of_list : ctyp list -> ctyp
-          
+
         val tySem_of_list : ctyp list -> ctyp
-          
+
         val tyCom_of_list : ctyp list -> ctyp
-          
+
         val tySta_of_list : ctyp list -> ctyp
-          
+
         val stSem_of_list : str_item list -> str_item
-          
+
         val sgSem_of_list : sig_item list -> sig_item
-          
+
         val crSem_of_list : class_str_item list -> class_str_item
-          
+
         val cgSem_of_list : class_sig_item list -> class_sig_item
-          
+
         val ctAnd_of_list : class_type list -> class_type
-          
+
         val ceAnd_of_list : class_expr list -> class_expr
-          
+
         val wcAnd_of_list : with_constr list -> with_constr
-          
+
         val meApp_of_list : module_expr list -> module_expr
-          
+
         val mbAnd_of_list : module_binding list -> module_binding
-          
+
         val mcOr_of_list : match_case list -> match_case
-          
+
         val idAcc_of_list : ident list -> ident
-          
+
         val idApp_of_list : ident list -> ident
-          
+
         val exSem_of_list : expr list -> expr
-          
+
         val exCom_of_list : expr list -> expr
-          
+
         val list_of_ctyp : ctyp -> ctyp list -> ctyp list
-          
+
         val list_of_binding : binding -> binding list -> binding list
-          
+
         val list_of_rec_binding :
           rec_binding -> rec_binding list -> rec_binding list
-          
+
         val list_of_with_constr :
           with_constr -> with_constr list -> with_constr list
-          
+
         val list_of_patt : patt -> patt list -> patt list
-          
+
         val list_of_expr : expr -> expr list -> expr list
-          
+
         val list_of_str_item : str_item -> str_item list -> str_item list
-          
+
         val list_of_sig_item : sig_item -> sig_item list -> sig_item list
-          
+
         val list_of_class_sig_item :
           class_sig_item -> class_sig_item list -> class_sig_item list
-          
+
         val list_of_class_str_item :
           class_str_item -> class_str_item list -> class_str_item list
-          
+
         val list_of_class_type :
           class_type -> class_type list -> class_type list
-          
+
         val list_of_class_expr :
           class_expr -> class_expr list -> class_expr list
-          
+
         val list_of_module_expr :
           module_expr -> module_expr list -> module_expr list
-          
+
         val list_of_module_binding :
           module_binding -> module_binding list -> module_binding list
-          
+
         val list_of_match_case :
           match_case -> match_case list -> match_case list
-          
+
         val list_of_ident : ident -> ident list -> ident list
-          
+
         val safe_string_escaped : string -> string
-          
+
         val is_irrefut_patt : patt -> bool
-          
+
         val is_constructor : ident -> bool
-          
+
         val is_patt_constructor : patt -> bool
-          
+
         val is_expr_constructor : expr -> bool
-          
+
         val ty_of_stl : (Loc.t * string * (ctyp list)) -> ctyp
-          
+
         val ty_of_sbt : (Loc.t * string * bool * ctyp) -> ctyp
-          
+
         val bi_of_pe : (patt * expr) -> binding
-          
+
         val pel_of_binding : binding -> (patt * expr) list
-          
+
         val binding_of_pel : (patt * expr) list -> binding
-          
+
         val sum_type_of_list : (Loc.t * string * (ctyp list)) list -> ctyp
-          
+
         val record_type_of_list : (Loc.t * string * bool * ctyp) list -> ctyp
-          
+
       end
-      
+
     module Camlp4AstToAst (M : Camlp4Ast) : Ast with type loc = M.loc
       and type meta_bool = M.meta_bool
       and type 'a meta_option = 'a M.meta_option
@@ -1781,7 +1791,7 @@ module Sig =
       and type virtual_flag = M.virtual_flag
       and type row_var_flag = M.row_var_flag
       and type override_flag = M.override_flag = M
-      
+
     module MakeCamlp4Ast (Loc : Type) =
       struct
         type loc =
@@ -2058,161 +2068,161 @@ module Sig =
           | CrVir of loc * string * private_flag * ctyp
           | CrVvr of loc * string * mutable_flag * ctyp
           | CrAnt of loc * string
-        
+
       end
-      
+
     type ('a, 'loc) stream_filter =
       ('a * 'loc) Stream.t -> ('a * 'loc) Stream.t
-    
+
     module type AstFilters =
       sig
         module Ast : Camlp4Ast
-          
+
         type 'a filter = 'a -> 'a
-        
+
         val register_sig_item_filter : Ast.sig_item filter -> unit
-          
+
         val register_str_item_filter : Ast.str_item filter -> unit
-          
+
         val register_topphrase_filter : Ast.str_item filter -> unit
-          
+
         val fold_interf_filters :
           ('a -> Ast.sig_item filter -> 'a) -> 'a -> 'a
-          
+
         val fold_implem_filters :
           ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
-          
+
         val fold_topphrase_filters :
           ('a -> Ast.str_item filter -> 'a) -> 'a -> 'a
-          
+
       end
-      
+
     module type DynAst =
       sig
         module Ast : Ast
-          
+
         type 'a tag
-        
+
         val ctyp_tag : Ast.ctyp tag
-          
+
         val patt_tag : Ast.patt tag
-          
+
         val expr_tag : Ast.expr tag
-          
+
         val module_type_tag : Ast.module_type tag
-          
+
         val sig_item_tag : Ast.sig_item tag
-          
+
         val with_constr_tag : Ast.with_constr tag
-          
+
         val module_expr_tag : Ast.module_expr tag
-          
+
         val str_item_tag : Ast.str_item tag
-          
+
         val class_type_tag : Ast.class_type tag
-          
+
         val class_sig_item_tag : Ast.class_sig_item tag
-          
+
         val class_expr_tag : Ast.class_expr tag
-          
+
         val class_str_item_tag : Ast.class_str_item tag
-          
+
         val match_case_tag : Ast.match_case tag
-          
+
         val ident_tag : Ast.ident tag
-          
+
         val binding_tag : Ast.binding tag
-          
+
         val rec_binding_tag : Ast.rec_binding tag
-          
+
         val module_binding_tag : Ast.module_binding tag
-          
+
         val string_of_tag : 'a tag -> string
-          
+
         module Pack (X : sig type 'a t
                               end) :
           sig
             type pack
-            
+
             val pack : 'a tag -> 'a X.t -> pack
-              
+
             val unpack : 'a tag -> pack -> 'a X.t
-              
+
             val print_tag : Format.formatter -> pack -> unit
-              
+
           end
-          
+
       end
-      
+
     type quotation =
       { q_name : string; q_loc : string; q_shift : int; q_contents : string
       }
-    
+
     module type Quotation =
       sig
         module Ast : Ast
-          
+
         module DynAst : DynAst with module Ast = Ast
-          
+
         open Ast
-          
+
         type 'a expand_fun = loc -> string option -> string -> 'a
-        
+
         val add : string -> 'a DynAst.tag -> 'a expand_fun -> unit
-          
+
         val find : string -> 'a DynAst.tag -> 'a expand_fun
-          
+
         val default : string ref
-          
+
         val parse_quotation_result :
           (loc -> string -> 'a) -> loc -> quotation -> string -> string -> 'a
-          
+
         val translate : (string -> string) ref
-          
+
         val expand : loc -> quotation -> 'a DynAst.tag -> 'a
-          
+
         val dump_file : (string option) ref
-          
+
         module Error : Error
-          
+
       end
-      
+
     module type Token =
       sig
         module Loc : Loc
-          
+
         type t
-        
+
         val to_string : t -> string
-          
+
         val print : Format.formatter -> t -> unit
-          
+
         val match_keyword : string -> t -> bool
-          
+
         val extract_string : t -> string
-          
+
         module Filter :
           sig
             type token_filter = (t, Loc.t) stream_filter
-            
+
             type t
-            
+
             val mk : (string -> bool) -> t
-              
+
             val define_filter : t -> (token_filter -> token_filter) -> unit
-              
+
             val filter : t -> token_filter
-              
+
             val keyword_added : t -> string -> bool -> unit
-              
+
             val keyword_removed : t -> string -> unit
-              
+
           end
-          
+
         module Error : Error
-          
+
       end
-      
+
     type camlp4_token =
       | KEYWORD of string
       | SYMBOL of string
@@ -2235,76 +2245,76 @@ module Sig =
       | NEWLINE
       | LINE_DIRECTIVE of int * string option
       | EOI
-    
+
     module type Camlp4Token = Token with type t = camlp4_token
-      
+
     module type DynLoader =
       sig
         type t
-        
+
         exception Error of string * string
-          
+
         val mk : ?ocaml_stdlib: bool -> ?camlp4_stdlib: bool -> unit -> t
-          
+
         val fold_load_path : t -> (string -> 'a -> 'a) -> 'a -> 'a
-          
+
         val load : t -> string -> unit
-          
+
         val include_dir : t -> string -> unit
-          
+
         val find_in_path : t -> string -> string
-          
+
         val is_native : bool
-          
+
       end
-      
+
     module Grammar =
       struct
         module type Action =
           sig
             type t
-            
+
             val mk : 'a -> t
-              
+
             val get : t -> 'a
-              
+
             val getf : t -> 'a -> 'b
-              
+
             val getf2 : t -> 'a -> 'b -> 'c
-              
+
           end
-          
+
         type assoc = | NonA | RightA | LeftA
-        
+
         type position =
           | First
           | Last
           | Before of string
           | After of string
           | Level of string
-        
+
         module type Structure =
           sig
             module Loc : Loc
-              
+
             module Action : Action
-              
+
             module Token : Token with module Loc = Loc
-              
+
             type gram
-            
+
             type internal_entry
-            
+
             type tree
-            
+
             type token_pattern = ((Token.t -> bool) * string)
-            
+
             type token_info
-            
+
             type token_stream = (Token.t * token_info) Stream.t
-            
+
             val token_location : token_info -> Loc.t
-              
+
             type symbol =
               | Smeta of string * symbol list * Action.t
               | Snterm of internal_entry
@@ -2320,201 +2330,201 @@ module Sig =
               | Stoken of token_pattern
               | Skeyword of string
               | Stree of tree
-            
+
             type production_rule = ((symbol list) * Action.t)
-            
+
             type single_extend_statment =
               ((string option) * (assoc option) * (production_rule list))
-            
+
             type extend_statment =
               ((position option) * (single_extend_statment list))
-            
+
             type delete_statment = symbol list
-            
+
             type ('a, 'b, 'c) fold =
               internal_entry ->
                 symbol list -> ('a Stream.t -> 'b) -> 'a Stream.t -> 'c
-            
+
             type ('a, 'b, 'c) foldsep =
               internal_entry ->
                 symbol list ->
                   ('a Stream.t -> 'b) ->
                     ('a Stream.t -> unit) -> 'a Stream.t -> 'c
-            
+
           end
-          
+
         module type Dynamic =
           sig
             include Structure
-              
+
             val mk : unit -> gram
-              
+
             module Entry :
               sig
                 type 'a t
-                
+
                 val mk : gram -> string -> 'a t
-                  
+
                 val of_parser :
                   gram -> string -> (token_stream -> 'a) -> 'a t
-                  
+
                 val setup_parser : 'a t -> (token_stream -> 'a) -> unit
-                  
+
                 val name : 'a t -> string
-                  
+
                 val print : Format.formatter -> 'a t -> unit
-                  
+
                 val dump : Format.formatter -> 'a t -> unit
-                  
+
                 val obj : 'a t -> internal_entry
-                  
+
                 val clear : 'a t -> unit
-                  
+
               end
-              
+
             val get_filter : gram -> Token.Filter.t
-              
+
             type 'a not_filtered
-            
+
             val extend : 'a Entry.t -> extend_statment -> unit
-              
+
             val delete_rule : 'a Entry.t -> delete_statment -> unit
-              
+
             val srules :
               'a Entry.t -> ((symbol list) * Action.t) list -> symbol
-              
+
             val sfold0 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-              
+
             val sfold1 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-              
+
             val sfold0sep : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) foldsep
-              
+
             val lex :
               gram ->
                 Loc.t ->
                   char Stream.t -> ((Token.t * Loc.t) Stream.t) not_filtered
-              
+
             val lex_string :
               gram ->
                 Loc.t -> string -> ((Token.t * Loc.t) Stream.t) not_filtered
-              
+
             val filter :
               gram ->
                 ((Token.t * Loc.t) Stream.t) not_filtered -> token_stream
-              
+
             val parse : 'a Entry.t -> Loc.t -> char Stream.t -> 'a
-              
+
             val parse_string : 'a Entry.t -> Loc.t -> string -> 'a
-              
+
             val parse_tokens_before_filter :
               'a Entry.t -> ((Token.t * Loc.t) Stream.t) not_filtered -> 'a
-              
+
             val parse_tokens_after_filter : 'a Entry.t -> token_stream -> 'a
-              
+
           end
-          
+
         module type Static =
           sig
             include Structure
-              
+
             module Entry :
               sig
                 type 'a t
-                
+
                 val mk : string -> 'a t
-                  
+
                 val of_parser : string -> (token_stream -> 'a) -> 'a t
-                  
+
                 val setup_parser : 'a t -> (token_stream -> 'a) -> unit
-                  
+
                 val name : 'a t -> string
-                  
+
                 val print : Format.formatter -> 'a t -> unit
-                  
+
                 val dump : Format.formatter -> 'a t -> unit
-                  
+
                 val obj : 'a t -> internal_entry
-                  
+
                 val clear : 'a t -> unit
-                  
+
               end
-              
+
             val get_filter : unit -> Token.Filter.t
-              
+
             type 'a not_filtered
-            
+
             val extend : 'a Entry.t -> extend_statment -> unit
-              
+
             val delete_rule : 'a Entry.t -> delete_statment -> unit
-              
+
             val srules :
               'a Entry.t -> ((symbol list) * Action.t) list -> symbol
-              
+
             val sfold0 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-              
+
             val sfold1 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-              
+
             val sfold0sep : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) foldsep
-              
+
             val lex :
               Loc.t ->
                 char Stream.t -> ((Token.t * Loc.t) Stream.t) not_filtered
-              
+
             val lex_string :
               Loc.t -> string -> ((Token.t * Loc.t) Stream.t) not_filtered
-              
+
             val filter :
               ((Token.t * Loc.t) Stream.t) not_filtered -> token_stream
-              
+
             val parse : 'a Entry.t -> Loc.t -> char Stream.t -> 'a
-              
+
             val parse_string : 'a Entry.t -> Loc.t -> string -> 'a
-              
+
             val parse_tokens_before_filter :
               'a Entry.t -> ((Token.t * Loc.t) Stream.t) not_filtered -> 'a
-              
+
             val parse_tokens_after_filter : 'a Entry.t -> token_stream -> 'a
-              
+
           end
-          
+
       end
-      
+
     module type Lexer =
       sig
         module Loc : Loc
-          
+
         module Token : Token with module Loc = Loc
-          
+
         module Error : Error
-          
+
         val mk : unit -> Loc.t -> char Stream.t -> (Token.t * Loc.t) Stream.t
-          
+
       end
-      
+
     module Parser (Ast : Ast) =
       struct
         module type SIMPLE =
           sig
             val parse_expr : Ast.loc -> string -> Ast.expr
-              
+
             val parse_patt : Ast.loc -> string -> Ast.patt
-              
+
           end
-          
+
         module type S =
           sig
             val parse_implem :
               ?directive_handler: (Ast.str_item -> Ast.str_item option) ->
                 Ast.loc -> char Stream.t -> Ast.str_item
-              
+
             val parse_interf :
               ?directive_handler: (Ast.sig_item -> Ast.sig_item option) ->
                 Ast.loc -> char Stream.t -> Ast.sig_item
-              
+
           end
-          
+
       end
-      
+
     module Printer (Ast : Ast) =
       struct
         module type S =
@@ -2522,436 +2532,436 @@ module Sig =
             val print_interf :
               ?input_file: string ->
                 ?output_file: string -> Ast.sig_item -> unit
-              
+
             val print_implem :
               ?input_file: string ->
                 ?output_file: string -> Ast.str_item -> unit
-              
+
           end
-          
+
       end
-      
+
     module type Syntax =
       sig
         module Loc : Loc
-          
+
         module Ast : Ast with type loc = Loc.t
-          
+
         module Token : Token with module Loc = Loc
-          
+
         module Gram : Grammar.Static with module Loc = Loc
           and module Token = Token
-          
+
         module Quotation : Quotation with module Ast = Ast
-          
+
         module AntiquotSyntax : Parser(Ast).SIMPLE
-          
+
         include Warning(Loc).S
-          
+
         include Parser(Ast).S
-          
+
         include Printer(Ast).S
-          
+
       end
-      
+
     module type Camlp4Syntax =
       sig
         module Loc : Loc
-          
+
         module Ast : Camlp4Ast with module Loc = Loc
-          
+
         module Token : Camlp4Token with module Loc = Loc
-          
+
         module Gram : Grammar.Static with module Loc = Loc
           and module Token = Token
-          
+
         module Quotation : Quotation with module Ast = Camlp4AstToAst(Ast)
-          
+
         module AntiquotSyntax : Parser(Ast).SIMPLE
-          
+
         include Warning(Loc).S
-          
+
         include Parser(Ast).S
-          
+
         include Printer(Ast).S
-          
+
         val interf : ((Ast.sig_item list) * (Loc.t option)) Gram.Entry.t
-          
+
         val implem : ((Ast.str_item list) * (Loc.t option)) Gram.Entry.t
-          
+
         val top_phrase : (Ast.str_item option) Gram.Entry.t
-          
+
         val use_file : ((Ast.str_item list) * (Loc.t option)) Gram.Entry.t
-          
+
         val a_CHAR : string Gram.Entry.t
-          
+
         val a_FLOAT : string Gram.Entry.t
-          
+
         val a_INT : string Gram.Entry.t
-          
+
         val a_INT32 : string Gram.Entry.t
-          
+
         val a_INT64 : string Gram.Entry.t
-          
+
         val a_LABEL : string Gram.Entry.t
-          
+
         val a_LIDENT : string Gram.Entry.t
-          
+
         val a_NATIVEINT : string Gram.Entry.t
-          
+
         val a_OPTLABEL : string Gram.Entry.t
-          
+
         val a_STRING : string Gram.Entry.t
-          
+
         val a_UIDENT : string Gram.Entry.t
-          
+
         val a_ident : string Gram.Entry.t
-          
+
         val amp_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val and_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val match_case : Ast.match_case Gram.Entry.t
-          
+
         val match_case0 : Ast.match_case Gram.Entry.t
-          
+
         val match_case_quot : Ast.match_case Gram.Entry.t
-          
+
         val binding : Ast.binding Gram.Entry.t
-          
+
         val binding_quot : Ast.binding Gram.Entry.t
-          
+
         val rec_binding_quot : Ast.rec_binding Gram.Entry.t
-          
+
         val class_declaration : Ast.class_expr Gram.Entry.t
-          
+
         val class_description : Ast.class_type Gram.Entry.t
-          
+
         val class_expr : Ast.class_expr Gram.Entry.t
-          
+
         val class_expr_quot : Ast.class_expr Gram.Entry.t
-          
+
         val class_fun_binding : Ast.class_expr Gram.Entry.t
-          
+
         val class_fun_def : Ast.class_expr Gram.Entry.t
-          
+
         val class_info_for_class_expr : Ast.class_expr Gram.Entry.t
-          
+
         val class_info_for_class_type : Ast.class_type Gram.Entry.t
-          
+
         val class_longident : Ast.ident Gram.Entry.t
-          
+
         val class_longident_and_param : Ast.class_expr Gram.Entry.t
-          
+
         val class_name_and_param : (string * Ast.ctyp) Gram.Entry.t
-          
+
         val class_sig_item : Ast.class_sig_item Gram.Entry.t
-          
+
         val class_sig_item_quot : Ast.class_sig_item Gram.Entry.t
-          
+
         val class_signature : Ast.class_sig_item Gram.Entry.t
-          
+
         val class_str_item : Ast.class_str_item Gram.Entry.t
-          
+
         val class_str_item_quot : Ast.class_str_item Gram.Entry.t
-          
+
         val class_structure : Ast.class_str_item Gram.Entry.t
-          
+
         val class_type : Ast.class_type Gram.Entry.t
-          
+
         val class_type_declaration : Ast.class_type Gram.Entry.t
-          
+
         val class_type_longident : Ast.ident Gram.Entry.t
-          
+
         val class_type_longident_and_param : Ast.class_type Gram.Entry.t
-          
+
         val class_type_plus : Ast.class_type Gram.Entry.t
-          
+
         val class_type_quot : Ast.class_type Gram.Entry.t
-          
+
         val comma_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val comma_expr : Ast.expr Gram.Entry.t
-          
+
         val comma_ipatt : Ast.patt Gram.Entry.t
-          
+
         val comma_patt : Ast.patt Gram.Entry.t
-          
+
         val comma_type_parameter : Ast.ctyp Gram.Entry.t
-          
+
         val constrain : (Ast.ctyp * Ast.ctyp) Gram.Entry.t
-          
+
         val constructor_arg_list : Ast.ctyp Gram.Entry.t
-          
+
         val constructor_declaration : Ast.ctyp Gram.Entry.t
-          
+
         val constructor_declarations : Ast.ctyp Gram.Entry.t
-          
+
         val ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val ctyp_quot : Ast.ctyp Gram.Entry.t
-          
+
         val cvalue_binding : Ast.expr Gram.Entry.t
-          
+
         val direction_flag : Ast.direction_flag Gram.Entry.t
-          
+
         val direction_flag_quot : Ast.direction_flag Gram.Entry.t
-          
+
         val dummy : unit Gram.Entry.t
-          
+
         val eq_expr : (string -> Ast.patt -> Ast.patt) Gram.Entry.t
-          
+
         val expr : Ast.expr Gram.Entry.t
-          
+
         val expr_eoi : Ast.expr Gram.Entry.t
-          
+
         val expr_quot : Ast.expr Gram.Entry.t
-          
+
         val field_expr : Ast.rec_binding Gram.Entry.t
-          
+
         val field_expr_list : Ast.rec_binding Gram.Entry.t
-          
+
         val fun_binding : Ast.expr Gram.Entry.t
-          
+
         val fun_def : Ast.expr Gram.Entry.t
-          
+
         val ident : Ast.ident Gram.Entry.t
-          
+
         val ident_quot : Ast.ident Gram.Entry.t
-          
+
         val ipatt : Ast.patt Gram.Entry.t
-          
+
         val ipatt_tcon : Ast.patt Gram.Entry.t
-          
+
         val label : string Gram.Entry.t
-          
+
         val label_declaration : Ast.ctyp Gram.Entry.t
-          
+
         val label_declaration_list : Ast.ctyp Gram.Entry.t
-          
+
         val label_expr : Ast.rec_binding Gram.Entry.t
-          
+
         val label_expr_list : Ast.rec_binding Gram.Entry.t
-          
+
         val label_ipatt : Ast.patt Gram.Entry.t
-          
+
         val label_ipatt_list : Ast.patt Gram.Entry.t
-          
+
         val label_longident : Ast.ident Gram.Entry.t
-          
+
         val label_patt : Ast.patt Gram.Entry.t
-          
+
         val label_patt_list : Ast.patt Gram.Entry.t
-          
+
         val labeled_ipatt : Ast.patt Gram.Entry.t
-          
+
         val let_binding : Ast.binding Gram.Entry.t
-          
+
         val meth_list : (Ast.ctyp * Ast.row_var_flag) Gram.Entry.t
-          
+
         val meth_decl : Ast.ctyp Gram.Entry.t
-          
+
         val module_binding : Ast.module_binding Gram.Entry.t
-          
+
         val module_binding0 : Ast.module_expr Gram.Entry.t
-          
+
         val module_binding_quot : Ast.module_binding Gram.Entry.t
-          
+
         val module_declaration : Ast.module_type Gram.Entry.t
-          
+
         val module_expr : Ast.module_expr Gram.Entry.t
-          
+
         val module_expr_quot : Ast.module_expr Gram.Entry.t
-          
+
         val module_longident : Ast.ident Gram.Entry.t
-          
+
         val module_longident_with_app : Ast.ident Gram.Entry.t
-          
+
         val module_rec_declaration : Ast.module_binding Gram.Entry.t
-          
+
         val module_type : Ast.module_type Gram.Entry.t
-          
+
         val package_type : Ast.module_type Gram.Entry.t
-          
+
         val module_type_quot : Ast.module_type Gram.Entry.t
-          
+
         val more_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val name_tags : Ast.ctyp Gram.Entry.t
-          
+
         val opt_as_lident : string Gram.Entry.t
-          
+
         val opt_class_self_patt : Ast.patt Gram.Entry.t
-          
+
         val opt_class_self_type : Ast.ctyp Gram.Entry.t
-          
+
         val opt_comma_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val opt_dot_dot : Ast.row_var_flag Gram.Entry.t
-          
+
         val row_var_flag_quot : Ast.row_var_flag Gram.Entry.t
-          
+
         val opt_eq_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val opt_expr : Ast.expr Gram.Entry.t
-          
+
         val opt_meth_list : Ast.ctyp Gram.Entry.t
-          
+
         val opt_mutable : Ast.mutable_flag Gram.Entry.t
-          
+
         val mutable_flag_quot : Ast.mutable_flag Gram.Entry.t
-          
+
         val opt_override : Ast.override_flag Gram.Entry.t
-          
+
         val override_flag_quot : Ast.override_flag Gram.Entry.t
-          
+
         val opt_polyt : Ast.ctyp Gram.Entry.t
-          
+
         val opt_private : Ast.private_flag Gram.Entry.t
-          
+
         val private_flag_quot : Ast.private_flag Gram.Entry.t
-          
+
         val opt_rec : Ast.rec_flag Gram.Entry.t
-          
+
         val rec_flag_quot : Ast.rec_flag Gram.Entry.t
-          
+
         val opt_virtual : Ast.virtual_flag Gram.Entry.t
-          
+
         val virtual_flag_quot : Ast.virtual_flag Gram.Entry.t
-          
+
         val opt_when_expr : Ast.expr Gram.Entry.t
-          
+
         val patt : Ast.patt Gram.Entry.t
-          
+
         val patt_as_patt_opt : Ast.patt Gram.Entry.t
-          
+
         val patt_eoi : Ast.patt Gram.Entry.t
-          
+
         val patt_quot : Ast.patt Gram.Entry.t
-          
+
         val patt_tcon : Ast.patt Gram.Entry.t
-          
+
         val phrase : Ast.str_item Gram.Entry.t
-          
+
         val poly_type : Ast.ctyp Gram.Entry.t
-          
+
         val row_field : Ast.ctyp Gram.Entry.t
-          
+
         val sem_expr : Ast.expr Gram.Entry.t
-          
+
         val sem_expr_for_list : (Ast.expr -> Ast.expr) Gram.Entry.t
-          
+
         val sem_patt : Ast.patt Gram.Entry.t
-          
+
         val sem_patt_for_list : (Ast.patt -> Ast.patt) Gram.Entry.t
-          
+
         val semi : unit Gram.Entry.t
-          
+
         val sequence : Ast.expr Gram.Entry.t
-          
+
         val do_sequence : Ast.expr Gram.Entry.t
-          
+
         val sig_item : Ast.sig_item Gram.Entry.t
-          
+
         val sig_item_quot : Ast.sig_item Gram.Entry.t
-          
+
         val sig_items : Ast.sig_item Gram.Entry.t
-          
+
         val star_ctyp : Ast.ctyp Gram.Entry.t
-          
+
         val str_item : Ast.str_item Gram.Entry.t
-          
+
         val str_item_quot : Ast.str_item Gram.Entry.t
-          
+
         val str_items : Ast.str_item Gram.Entry.t
-          
+
         val type_constraint : unit Gram.Entry.t
-          
+
         val type_declaration : Ast.ctyp Gram.Entry.t
-          
+
         val type_ident_and_parameters :
           (string * (Ast.ctyp list)) Gram.Entry.t
-          
+
         val type_kind : Ast.ctyp Gram.Entry.t
-          
+
         val type_longident : Ast.ident Gram.Entry.t
-          
+
         val type_longident_and_parameters : Ast.ctyp Gram.Entry.t
-          
+
         val type_parameter : Ast.ctyp Gram.Entry.t
-          
+
         val type_parameters : (Ast.ctyp -> Ast.ctyp) Gram.Entry.t
-          
+
         val typevars : Ast.ctyp Gram.Entry.t
-          
+
         val val_longident : Ast.ident Gram.Entry.t
-          
+
         val value_let : unit Gram.Entry.t
-          
+
         val value_val : unit Gram.Entry.t
-          
+
         val with_constr : Ast.with_constr Gram.Entry.t
-          
+
         val with_constr_quot : Ast.with_constr Gram.Entry.t
-          
+
         val prefixop : Ast.expr Gram.Entry.t
-          
+
         val infixop0 : Ast.expr Gram.Entry.t
-          
+
         val infixop1 : Ast.expr Gram.Entry.t
-          
+
         val infixop2 : Ast.expr Gram.Entry.t
-          
+
         val infixop3 : Ast.expr Gram.Entry.t
-          
+
         val infixop4 : Ast.expr Gram.Entry.t
-          
+
       end
-      
+
     module type SyntaxExtension =
       functor (Syn : Syntax) -> Syntax with module Loc = Syn.Loc
         and module Ast = Syn.Ast and module Token = Syn.Token
         and module Gram = Syn.Gram and module Quotation = Syn.Quotation
-      
+
   end
-  
+
 module ErrorHandler :
   sig
     val print : Format.formatter -> exn -> unit
-      
+
     val try_print : Format.formatter -> exn -> unit
-      
+
     val to_string : exn -> string
-      
+
     val try_to_string : exn -> string
-      
+
     val register : (Format.formatter -> exn -> unit) -> unit
-      
+
     module Register (Error : Sig.Error) : sig  end
-      
+
     module ObjTools :
       sig
         val print : Format.formatter -> Obj.t -> unit
-          
+
         val print_desc : Format.formatter -> Obj.t -> unit
-          
+
         val to_string : Obj.t -> string
-          
+
         val desc : Obj.t -> string
-          
+
       end
-      
+
   end =
   struct
     open Format
-      
+
     module ObjTools =
       struct
         let desc obj =
           if Obj.is_block obj
           then "tag = " ^ (string_of_int (Obj.tag obj))
           else "int_val = " ^ (string_of_int (Obj.obj obj))
-          
+
         let rec to_string r =
           if Obj.is_int r
           then
@@ -3027,13 +3037,13 @@ module ErrorHandler :
                    failwith
                      ("ObjTools.to_string: unknown tag (" ^
                         ((string_of_int t) ^ ")")))
-          
+
         let print ppf x = fprintf ppf "%s" (to_string x)
-          
+
         let print_desc ppf x = fprintf ppf "%s" (desc x)
-          
+
       end
-      
+
     let default_handler ppf x =
       let x = Obj.repr x
       in
@@ -3054,10 +3064,10 @@ module ErrorHandler :
                pp_print_char ppf ')')
             else ());
          fprintf ppf "@.")
-      
+
     let handler =
       ref (fun ppf default_handler exn -> default_handler ppf exn)
-      
+
     let register f =
       let current_handler = !handler
       in
@@ -3065,7 +3075,7 @@ module ErrorHandler :
           fun ppf default_handler exn ->
             try f ppf exn
             with | exn -> current_handler ppf default_handler exn
-      
+
     module Register (Error : Sig.Error) =
       struct
         let _ =
@@ -3076,9 +3086,9 @@ module ErrorHandler :
                 function
                 | Error.E x -> Error.print ppf x
                 | x -> current_handler ppf default_handler x
-          
+
       end
-      
+
     let gen_print ppf default_handler =
       function
       | Out_of_memory -> fprintf ppf "Out of memory"
@@ -3094,34 +3104,34 @@ module ErrorHandler :
       | Stream.Failure -> fprintf ppf "Parse failure"
       | Stream.Error str -> fprintf ppf "Parse error: %s" str
       | x -> !handler ppf default_handler x
-      
+
     let print ppf = gen_print ppf default_handler
-      
+
     let try_print ppf = gen_print ppf (fun _ -> raise)
-      
+
     let to_string exn =
       let buf = Buffer.create 128 in
       let () = bprintf buf "%a" print exn in Buffer.contents buf
-      
+
     let try_to_string exn =
       let buf = Buffer.create 128 in
       let () = bprintf buf "%a" try_print exn in Buffer.contents buf
-      
+
   end
-  
+
 module Struct =
   struct
     module Loc : sig include Sig.Loc
                         end =
       struct
         open Format
-          
+
         type pos = { line : int; bol : int; off : int }
-        
+
         type t =
           { file_name : string; start : pos; stop : pos; ghost : bool
           }
-        
+
         let dump_sel f x =
           let s =
             match x with
@@ -3130,26 +3140,26 @@ module Struct =
             | `both -> "`both"
             | _ -> "<not-printable>"
           in pp_print_string f s
-          
+
         let dump_pos f x =
           fprintf f "@[<hov 2>{ line = %d ;@ bol = %d ;@ off = %d } : pos@]"
             x.line x.bol x.off
-          
+
         let dump_long f x =
           fprintf f
             "@[<hov 2>{ file_name = %s ;@ start = %a (%d-%d);@ stop = %a (%d);@ ghost = %b@ } : Loc.t@]"
             x.file_name dump_pos x.start (x.start.off - x.start.bol)
             (x.stop.off - x.start.bol) dump_pos x.stop
             (x.stop.off - x.stop.bol) x.ghost
-          
+
         let dump f x =
           fprintf f "[%S: %d:%d-%d %d:%d%t]" x.file_name x.start.line
             (x.start.off - x.start.bol) (x.stop.off - x.start.bol)
             x.stop.line (x.stop.off - x.stop.bol)
             (fun o -> if x.ghost then fprintf o " (ghost)" else ())
-          
+
         let start_pos = { line = 1; bol = 0; off = 0; }
-          
+
         let ghost =
           {
             file_name = "ghost-location";
@@ -3157,7 +3167,7 @@ module Struct =
             stop = start_pos;
             ghost = true;
           }
-          
+
         let mk file_name =
           {
             file_name = file_name;
@@ -3165,7 +3175,7 @@ module Struct =
             stop = start_pos;
             ghost = false;
           }
-          
+
         let of_tuple (file_name, start_line, start_bol, start_off, stop_line,
                       stop_bol, stop_off, ghost)
                      =
@@ -3175,7 +3185,7 @@ module Struct =
             stop = { line = stop_line; bol = stop_bol; off = stop_off; };
             ghost = ghost;
           }
-          
+
         let to_tuple {
                        file_name = file_name;
                        start =
@@ -3190,7 +3200,7 @@ module Struct =
                      } =
           (file_name, start_line, start_bol, start_off, stop_line, stop_bol,
            stop_off, ghost)
-          
+
         let pos_of_lexing_position p =
           let pos =
             {
@@ -3199,7 +3209,7 @@ module Struct =
               off = p.Lexing.pos_cnum;
             }
           in pos
-          
+
         let pos_to_lexing_position p file_name =
           {
             Lexing.pos_fname = file_name;
@@ -3207,7 +3217,7 @@ module Struct =
             pos_bol = p.bol;
             pos_cnum = p.off;
           }
-          
+
         let better_file_name a b =
           match (a, b) with
           | ("", "") -> a
@@ -3216,7 +3226,7 @@ module Struct =
           | ("-", x) -> x
           | (x, "-") -> x
           | (x, _) -> x
-          
+
         let of_lexbuf lb =
           let start = Lexing.lexeme_start_p lb
           and stop = Lexing.lexeme_end_p lb in
@@ -3229,7 +3239,7 @@ module Struct =
               ghost = false;
             }
           in loc
-          
+
         let of_lexing_position pos =
           let loc =
             {
@@ -3239,14 +3249,14 @@ module Struct =
               ghost = false;
             }
           in loc
-          
+
         let to_ocaml_location x =
           {
             Location.loc_start = pos_to_lexing_position x.start x.file_name;
             loc_end = pos_to_lexing_position x.stop x.file_name;
             loc_ghost = x.ghost;
           }
-          
+
         let of_ocaml_location {
                                 Location.loc_start = a;
                                 loc_end = b;
@@ -3261,11 +3271,11 @@ module Struct =
               ghost = g;
             }
           in res
-          
+
         let start_pos x = pos_to_lexing_position x.start x.file_name
-          
+
         let stop_pos x = pos_to_lexing_position x.stop x.file_name
-          
+
         let merge a b =
           if a == b
           then a
@@ -3277,58 +3287,58 @@ module Struct =
                | (true, _) -> { (a) with stop = b.stop; }
                | (_, true) -> { (b) with start = a.start; }
              in r)
-          
+
         let join x = { (x) with stop = x.start; }
-          
+
         let map f start_stop_both x =
           match start_stop_both with
           | `start -> { (x) with start = f x.start; }
           | `stop -> { (x) with stop = f x.stop; }
           | `both -> { (x) with start = f x.start; stop = f x.stop; }
-          
+
         let move_pos chars x = { (x) with off = x.off + chars; }
-          
+
         let move s chars x = map (move_pos chars) s x
-          
+
         let move_line lines x =
           let move_line_pos x =
             { (x) with line = x.line + lines; bol = x.off; }
           in map move_line_pos `both x
-          
+
         let shift width x =
           { (x) with start = x.stop; stop = move_pos width x.stop; }
-          
+
         let file_name x = x.file_name
-          
+
         let start_line x = x.start.line
-          
+
         let stop_line x = x.stop.line
-          
+
         let start_bol x = x.start.bol
-          
+
         let stop_bol x = x.stop.bol
-          
+
         let start_off x = x.start.off
-          
+
         let stop_off x = x.stop.off
-          
+
         let is_ghost x = x.ghost
-          
+
         let set_file_name s x = { (x) with file_name = s; }
-          
+
         let ghostify x = { (x) with ghost = true; }
-          
+
         let make_absolute x =
           let pwd = Sys.getcwd ()
           in
             if Filename.is_relative x.file_name
             then { (x) with file_name = Filename.concat pwd x.file_name; }
             else x
-          
+
         let strictly_before x y =
           let b = (x.stop.off < y.start.off) && (x.file_name = y.file_name)
           in b
-          
+
         let to_string x =
           let (a, b) = ((x.start), (x.stop)) in
           let res =
@@ -3340,9 +3350,9 @@ module Struct =
               sprintf "%s (end at line %d, character %d)" res x.stop.line
                 (b.off - b.bol)
             else res
-          
+
         let print out x = pp_print_string out (to_string x)
-          
+
         let check x msg =
           if
             ((start_line x) > (stop_line x)) ||
@@ -3358,9 +3368,9 @@ module Struct =
                print x;
              false)
           else true
-          
+
         exception Exc_located of t * exn
-          
+
         let _ =
           ErrorHandler.register
             (fun ppf ->
@@ -3368,42 +3378,42 @@ module Struct =
                | Exc_located (loc, exn) ->
                    fprintf ppf "%a:@\n%a" print loc ErrorHandler.print exn
                | exn -> raise exn)
-          
+
         let name = ref "_loc"
-          
+
         let raise loc exc =
           match exc with
           | Exc_located (_, _) -> raise exc
           | _ -> raise (Exc_located (loc, exc))
-          
+
       end
-      
+
     module Token :
       sig
         module Make (Loc : Sig.Loc) : Sig.Camlp4Token with module Loc = Loc
-          
+
         module Eval :
           sig
             val char : string -> char
-              
+
             val string : ?strict: unit -> string -> string
-              
+
           end
-          
+
       end =
       struct
         open Format
-          
+
         module Make (Loc : Sig.Loc) : Sig.Camlp4Token with module Loc = Loc =
           struct
             module Loc = Loc
-              
+
             open Sig
-              
+
             type t = camlp4_token
-            
+
             type token = t
-            
+
             let to_string =
               function
               | KEYWORD s -> sprintf "KEYWORD %S" s
@@ -3432,12 +3442,12 @@ module Struct =
               | LINE_DIRECTIVE (i, None) -> sprintf "LINE_DIRECTIVE %d" i
               | LINE_DIRECTIVE (i, (Some s)) ->
                   sprintf "LINE_DIRECTIVE %d %S" i s
-              
+
             let print ppf x = pp_print_string ppf (to_string x)
-              
+
             let match_keyword kwd =
               function | KEYWORD kwd' when kwd = kwd' -> true | _ -> false
-              
+
             let extract_string =
               function
               | KEYWORD s | SYMBOL s | LIDENT s | UIDENT s | INT (_, s) |
@@ -3448,7 +3458,7 @@ module Struct =
                   invalid_arg
                     ("Cannot extract a string from this token: " ^
                        (to_string tok))
-              
+
             module Error =
               struct
                 type t =
@@ -3456,9 +3466,9 @@ module Struct =
                   | Keyword_as_label of string
                   | Illegal_token_pattern of string * string
                   | Illegal_constructor of string
-                
+
                 exception E of t
-                  
+
                 let print ppf =
                   function
                   | Illegal_token s -> fprintf ppf "Illegal token (%s)" s
@@ -3470,32 +3480,32 @@ module Struct =
                       fprintf ppf "Illegal token pattern: %s %S" p_con p_prm
                   | Illegal_constructor con ->
                       fprintf ppf "Illegal constructor %S" con
-                  
+
                 let to_string x =
                   let b = Buffer.create 50 in
                   let () = bprintf b "%a" print x in Buffer.contents b
-                  
+
               end
-              
+
             let _ = let module M = ErrorHandler.Register(Error) in ()
-              
+
             module Filter =
               struct
                 type token_filter = (t, Loc.t) stream_filter
-                
+
                 type t =
                   { is_kwd : string -> bool; mutable filter : token_filter
                   }
-                
+
                 let err error loc =
                   raise (Loc.Exc_located (loc, (Error.E error)))
-                  
+
                 let keyword_conversion tok is_kwd =
                   match tok with
                   | SYMBOL s | LIDENT s | UIDENT s when is_kwd s -> KEYWORD s
                   | ESCAPED_IDENT s -> LIDENT s
                   | _ -> tok
-                  
+
                 let check_keyword_as_label tok loc is_kwd =
                   let s =
                     match tok with | LABEL s -> s | OPTLABEL s -> s | _ -> ""
@@ -3503,20 +3513,20 @@ module Struct =
                     if (s <> "") && (is_kwd s)
                     then err (Error.Keyword_as_label s) loc
                     else ()
-                  
+
                 let check_unknown_keywords tok loc =
                   match tok with
                   | SYMBOL s -> err (Error.Illegal_token s) loc
                   | _ -> ()
-                  
+
                 let error_no_respect_rules p_con p_prm =
                   raise
                     (Error.E (Error.Illegal_token_pattern (p_con, p_prm)))
-                  
+
                 let check_keyword _ = true
-                  
+
                 let error_on_unknown_keywords = ref false
-                  
+
                 let rec ignore_layout (__strm : _ Stream.t) =
                   match Stream.peek __strm with
                   | Some
@@ -3531,9 +3541,9 @@ module Struct =
                          Stream.icons x
                            (Stream.slazy (fun _ -> ignore_layout s)))
                   | _ -> Stream.sempty
-                  
+
                 let mk is_kwd = { is_kwd = is_kwd; filter = ignore_layout; }
-                  
+
                 let filter x =
                   let f tok loc =
                     let tok = keyword_conversion tok x.is_kwd
@@ -3561,43 +3571,43 @@ module Struct =
                            Stream.icons x (Stream.slazy (fun _ -> tracer xs)))
                     | _ -> Stream.sempty
                   in fun strm -> tracer (x.filter (filter strm))
-                  
+
                 let define_filter x f = x.filter <- f x.filter
-                  
+
                 let keyword_added _ _ _ = ()
-                  
+
                 let keyword_removed _ _ = ()
-                  
+
               end
-              
+
           end
-          
+
         module Eval =
           struct
             let valch x = (Char.code x) - (Char.code '0')
-              
+
             let valch_hex x =
               let d = Char.code x
               in
                 if d >= 97
                 then d - 87
                 else if d >= 65 then d - 55 else d - 48
-              
+
             let rec skip_indent (__strm : _ Stream.t) =
               match Stream.peek __strm with
               | Some (' ' | '\t') -> (Stream.junk __strm; skip_indent __strm)
               | _ -> ()
-              
+
             let skip_opt_linefeed (__strm : _ Stream.t) =
               match Stream.peek __strm with
               | Some '\n' -> (Stream.junk __strm; ())
               | _ -> ()
-              
+
             let chr c =
               if (c < 0) || (c > 255)
               then failwith "invalid char token"
               else Char.chr c
-              
+
             let rec backslash (__strm : _ Stream.t) =
               match Stream.peek __strm with
               | Some '\n' -> (Stream.junk __strm; '\n')
@@ -3637,7 +3647,7 @@ module Struct =
                           | _ -> raise (Stream.Error "")))
                     | _ -> raise (Stream.Error "")))
               | _ -> raise Stream.Failure
-              
+
             let rec backslash_in_string strict store (__strm : _ Stream.t) =
               match Stream.peek __strm with
               | Some '\n' -> (Stream.junk __strm; skip_indent __strm)
@@ -3654,7 +3664,7 @@ module Struct =
                         | Some c when not strict ->
                             (Stream.junk __strm; store '\\'; store c)
                         | _ -> failwith "invalid string token"))
-              
+
             let char s =
               if (String.length s) = 1
               then s.[0]
@@ -3670,7 +3680,7 @@ module Struct =
                           (try backslash __strm
                            with | Stream.Failure -> raise (Stream.Error "")))
                      | _ -> failwith "invalid char token")
-              
+
             let string ?strict s =
               let buf = Buffer.create 23 in
               let store = Buffer.add_char buf in
@@ -3687,25 +3697,25 @@ module Struct =
                      let s = __strm in (store c; parse s))
                 | _ -> Buffer.contents buf
               in parse (Stream.of_string s)
-              
+
           end
-          
+
       end
-      
+
     module Lexer =
       struct
         module TokenEval = Token.Eval
-          
+
         module Make (Token : Sig.Camlp4Token) =
           struct
             module Loc = Token.Loc
-              
+
             module Token = Token
-              
+
             open Lexing
-              
+
             open Sig
-              
+
             module Error =
               struct
                 type t =
@@ -3719,11 +3729,11 @@ module Struct =
                   | Comment_start
                   | Comment_not_end
                   | Literal_overflow of string
-                
+
                 exception E of t
-                  
+
                 open Format
-                  
+
                 let print ppf =
                   function
                   | Illegal_character c ->
@@ -3751,22 +3761,22 @@ module Struct =
                       fprintf ppf "this is the start of a comment"
                   | Comment_not_end ->
                       fprintf ppf "this is not the end of a comment"
-                  
+
                 let to_string x =
                   let b = Buffer.create 50 in
                   let () = bprintf b "%a" print x in Buffer.contents b
-                  
+
               end
-              
+
             let _ = let module M = ErrorHandler.Register(Error) in ()
-              
+
             open Error
-              
+
             type context =
               { loc : Loc.t; in_comment : bool; quotations : bool;
                 antiquots : bool; lexbuf : lexbuf; buffer : Buffer.t
               }
-            
+
             let default_context lb =
               {
                 loc = Loc.ghost;
@@ -3776,47 +3786,47 @@ module Struct =
                 lexbuf = lb;
                 buffer = Buffer.create 256;
               }
-              
+
             let store c = Buffer.add_string c.buffer (Lexing.lexeme c.lexbuf)
-              
+
             let istore_char c i =
               Buffer.add_char c.buffer (Lexing.lexeme_char c.lexbuf i)
-              
+
             let buff_contents c =
               let contents = Buffer.contents c.buffer
               in (Buffer.reset c.buffer; contents)
-              
+
             let loc c = Loc.merge c.loc (Loc.of_lexbuf c.lexbuf)
-              
+
             let quotations c = c.quotations
-              
+
             let antiquots c = c.antiquots
-              
+
             let is_in_comment c = c.in_comment
-              
+
             let in_comment c = { (c) with in_comment = true; }
-              
+
             let set_start_p c = c.lexbuf.lex_start_p <- Loc.start_pos c.loc
-              
+
             let move_start_p shift c =
               let p = c.lexbuf.lex_start_p
               in
                 c.lexbuf.lex_start_p <-
                   { (p) with pos_cnum = p.pos_cnum + shift; }
-              
+
             let update_loc c = { (c) with loc = Loc.of_lexbuf c.lexbuf; }
-              
+
             let with_curr_loc f c = f (update_loc c) c.lexbuf
-              
+
             let parse_nested f c =
               (with_curr_loc f c; set_start_p c; buff_contents c)
-              
+
             let shift n c = { (c) with loc = Loc.move `both n c.loc; }
-              
+
             let store_parse f c = (store c; f c c.lexbuf)
-              
+
             let parse f c = f c c.lexbuf
-              
+
             let mk_quotation quotation c name loc shift =
               let s = parse_nested quotation (update_loc c) in
               let contents = String.sub s 0 ((String.length s) - 2)
@@ -3828,7 +3838,7 @@ module Struct =
                     q_shift = shift;
                     q_contents = contents;
                   }
-              
+
             let update_loc c file line absolute chars =
               let lexbuf = c.lexbuf in
               let pos = lexbuf.lex_curr_p in
@@ -3843,23 +3853,23 @@ module Struct =
                     pos_lnum = if absolute then line else pos.pos_lnum + line;
                     pos_bol = pos.pos_cnum - chars;
                   }
-              
+
             let cvt_int_literal s = - (int_of_string ("-" ^ s))
-              
+
             let cvt_int32_literal s = Int32.neg (Int32.of_string ("-" ^ s))
-              
+
             let cvt_int64_literal s = Int64.neg (Int64.of_string ("-" ^ s))
-              
+
             let cvt_nativeint_literal s =
               Nativeint.neg (Nativeint.of_string ("-" ^ s))
-              
+
             let err error loc =
               raise (Loc.Exc_located (loc, (Error.E error)))
-              
+
             let warn error loc =
               Format.eprintf "Warning: %a: %a@." Loc.print loc Error.print
                 error
-              
+
             let __ocaml_lex_tables =
               {
                 Lexing.lex_base =
@@ -6405,7 +6415,7 @@ module Struct =
     \255\000\004\001\009\003\010\002\011\255\001\255\255\000\001\255\
     ";
               }
-              
+
             let rec token c lexbuf =
               (lexbuf.Lexing.lex_mem <- Array.create 12 (-1);
                __ocaml_lex_token_rec c lexbuf 0)
@@ -6812,7 +6822,7 @@ module Struct =
               | __ocaml_lex_state ->
                   (lexbuf.Lexing.refill_buff lexbuf;
                    __ocaml_lex_antiquot_rec name c lexbuf __ocaml_lex_state)
-              
+
             let lexing_store s buff max =
               let rec self n s =
                 if n >= max
@@ -6822,13 +6832,13 @@ module Struct =
                    | Some x -> (Stream.junk s; buff.[n] <- x; succ n)
                    | _ -> n)
               in self 0 s
-              
+
             let from_context c =
               let next _ =
                 let tok = with_curr_loc token c in
                 let loc = Loc.of_lexbuf c.lexbuf in Some (tok, loc)
               in Stream.from next
-              
+
             let from_lexbuf ?(quotations = true) lb =
               let c =
                 {
@@ -6839,88 +6849,88 @@ module Struct =
                   quotations = quotations;
                 }
               in from_context c
-              
+
             let setup_loc lb loc =
               let start_pos = Loc.start_pos loc
               in
                 (lb.lex_abs_pos <- start_pos.pos_cnum;
                  lb.lex_curr_p <- start_pos)
-              
+
             let from_string ?quotations loc str =
               let lb = Lexing.from_string str
               in (setup_loc lb loc; from_lexbuf ?quotations lb)
-              
+
             let from_stream ?quotations loc strm =
               let lb = Lexing.from_function (lexing_store strm)
               in (setup_loc lb loc; from_lexbuf ?quotations lb)
-              
+
             let mk () loc strm =
               from_stream ~quotations: !Camlp4_config.quotations loc strm
-              
+
           end
-          
+
       end
-      
+
     module Camlp4Ast =
       struct
         module Make (Loc : Sig.Loc) : Sig.Camlp4Ast with module Loc = Loc =
           struct
             module Loc = Loc
-              
+
             module Ast =
               struct
                 include Sig.MakeCamlp4Ast(Loc)
-                  
+
                 let safe_string_escaped s =
                   if
                     ((String.length s) > 2) &&
                       ((s.[0] = '\\') && (s.[1] = '$'))
                   then s
                   else String.escaped s
-                  
+
               end
-              
+
             include Ast
-              
+
             external loc_of_ctyp : ctyp -> Loc.t = "%field0"
-              
+
             external loc_of_patt : patt -> Loc.t = "%field0"
-              
+
             external loc_of_expr : expr -> Loc.t = "%field0"
-              
+
             external loc_of_module_type : module_type -> Loc.t = "%field0"
-              
+
             external loc_of_module_expr : module_expr -> Loc.t = "%field0"
-              
+
             external loc_of_sig_item : sig_item -> Loc.t = "%field0"
-              
+
             external loc_of_str_item : str_item -> Loc.t = "%field0"
-              
+
             external loc_of_class_type : class_type -> Loc.t = "%field0"
-              
+
             external loc_of_class_sig_item : class_sig_item -> Loc.t =
               "%field0"
-              
+
             external loc_of_class_expr : class_expr -> Loc.t = "%field0"
-              
+
             external loc_of_class_str_item : class_str_item -> Loc.t =
               "%field0"
-              
+
             external loc_of_with_constr : with_constr -> Loc.t = "%field0"
-              
+
             external loc_of_binding : binding -> Loc.t = "%field0"
-              
+
             external loc_of_rec_binding : rec_binding -> Loc.t = "%field0"
-              
+
             external loc_of_module_binding : module_binding -> Loc.t =
               "%field0"
-              
+
             external loc_of_match_case : match_case -> Loc.t = "%field0"
-              
+
             external loc_of_ident : ident -> Loc.t = "%field0"
-              
+
             let ghost = Loc.ghost
-              
+
             let rec is_module_longident =
               function
               | Ast.IdAcc (_, _, i) -> is_module_longident i
@@ -6928,7 +6938,7 @@ module Struct =
                   (is_module_longident i1) && (is_module_longident i2)
               | Ast.IdUid (_, _) -> true
               | _ -> false
-              
+
             let ident_of_expr =
               let error () =
                 invalid_arg
@@ -6948,7 +6958,7 @@ module Struct =
                 | Ast.ExId (_, i) -> i
                 | Ast.ExApp (_, _, _) -> error ()
                 | t -> self t
-              
+
             let ident_of_ctyp =
               let error () =
                 invalid_arg "ident_of_ctyp: this type is not an identifier" in
@@ -6961,7 +6971,7 @@ module Struct =
                     if is_module_longident i then i else error ()
                 | _ -> error ()
               in function | Ast.TyId (_, i) -> i | t -> self t
-              
+
             let ident_of_patt =
               let error () =
                 invalid_arg
@@ -6975,7 +6985,7 @@ module Struct =
                     if is_module_longident i then i else error ()
                 | _ -> error ()
               in function | Ast.PaId (_, i) -> i | p -> self p
-              
+
             let rec is_irrefut_patt =
               function
               | Ast.PaId (_, (Ast.IdLid (_, _))) -> true
@@ -7010,20 +7020,20 @@ module Struct =
                   Ast.PaInt64 (_, _) | Ast.PaInt32 (_, _) | Ast.PaInt (_, _)
                   | Ast.PaChr (_, _) | Ast.PaTyp (_, _) | Ast.PaArr (_, _) |
                   Ast.PaAnt (_, _) -> false
-              
+
             let rec is_constructor =
               function
               | Ast.IdAcc (_, _, i) -> is_constructor i
               | Ast.IdUid (_, _) -> true
               | Ast.IdLid (_, _) | Ast.IdApp (_, _, _) -> false
               | Ast.IdAnt (_, _) -> assert false
-              
+
             let is_patt_constructor =
               function
               | Ast.PaId (_, i) -> is_constructor i
               | Ast.PaVrn (_, _) -> true
               | _ -> false
-              
+
             let rec is_expr_constructor =
               function
               | Ast.ExId (_, i) -> is_constructor i
@@ -7031,7 +7041,7 @@ module Struct =
                   (is_expr_constructor e1) && (is_expr_constructor e2)
               | Ast.ExVrn (_, _) -> true
               | _ -> false
-              
+
             let rec tyOr_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7039,7 +7049,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TyOr (_loc, t, (tyOr_of_list ts))
-              
+
             let rec tyAnd_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7047,7 +7057,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TyAnd (_loc, t, (tyAnd_of_list ts))
-              
+
             let rec tySem_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7055,7 +7065,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TySem (_loc, t, (tySem_of_list ts))
-              
+
             let rec tyCom_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7063,7 +7073,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TyCom (_loc, t, (tyCom_of_list ts))
-              
+
             let rec tyAmp_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7071,7 +7081,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TyAmp (_loc, t, (tyAmp_of_list ts))
-              
+
             let rec tySta_of_list =
               function
               | [] -> Ast.TyNil ghost
@@ -7079,7 +7089,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_ctyp t
                   in Ast.TySta (_loc, t, (tySta_of_list ts))
-              
+
             let rec stSem_of_list =
               function
               | [] -> Ast.StNil ghost
@@ -7087,7 +7097,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_str_item t
                   in Ast.StSem (_loc, t, (stSem_of_list ts))
-              
+
             let rec sgSem_of_list =
               function
               | [] -> Ast.SgNil ghost
@@ -7095,7 +7105,7 @@ module Struct =
               | t :: ts ->
                   let _loc = loc_of_sig_item t
                   in Ast.SgSem (_loc, t, (sgSem_of_list ts))
-              
+
             let rec biAnd_of_list =
               function
               | [] -> Ast.BiNil ghost
@@ -7103,7 +7113,7 @@ module Struct =
               | b :: bs ->
                   let _loc = loc_of_binding b
                   in Ast.BiAnd (_loc, b, (biAnd_of_list bs))
-              
+
             let rec rbSem_of_list =
               function
               | [] -> Ast.RbNil ghost
@@ -7111,7 +7121,7 @@ module Struct =
               | b :: bs ->
                   let _loc = loc_of_rec_binding b
                   in Ast.RbSem (_loc, b, (rbSem_of_list bs))
-              
+
             let rec wcAnd_of_list =
               function
               | [] -> Ast.WcNil ghost
@@ -7119,7 +7129,7 @@ module Struct =
               | w :: ws ->
                   let _loc = loc_of_with_constr w
                   in Ast.WcAnd (_loc, w, (wcAnd_of_list ws))
-              
+
             let rec idAcc_of_list =
               function
               | [] -> assert false
@@ -7127,7 +7137,7 @@ module Struct =
               | i :: is ->
                   let _loc = loc_of_ident i
                   in Ast.IdAcc (_loc, i, (idAcc_of_list is))
-              
+
             let rec idApp_of_list =
               function
               | [] -> assert false
@@ -7135,7 +7145,7 @@ module Struct =
               | i :: is ->
                   let _loc = loc_of_ident i
                   in Ast.IdApp (_loc, i, (idApp_of_list is))
-              
+
             let rec mcOr_of_list =
               function
               | [] -> Ast.McNil ghost
@@ -7143,7 +7153,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_match_case x
                   in Ast.McOr (_loc, x, (mcOr_of_list xs))
-              
+
             let rec mbAnd_of_list =
               function
               | [] -> Ast.MbNil ghost
@@ -7151,7 +7161,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_module_binding x
                   in Ast.MbAnd (_loc, x, (mbAnd_of_list xs))
-              
+
             let rec meApp_of_list =
               function
               | [] -> assert false
@@ -7159,7 +7169,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_module_expr x
                   in Ast.MeApp (_loc, x, (meApp_of_list xs))
-              
+
             let rec ceAnd_of_list =
               function
               | [] -> Ast.CeNil ghost
@@ -7167,7 +7177,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_class_expr x
                   in Ast.CeAnd (_loc, x, (ceAnd_of_list xs))
-              
+
             let rec ctAnd_of_list =
               function
               | [] -> Ast.CtNil ghost
@@ -7175,7 +7185,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_class_type x
                   in Ast.CtAnd (_loc, x, (ctAnd_of_list xs))
-              
+
             let rec cgSem_of_list =
               function
               | [] -> Ast.CgNil ghost
@@ -7183,7 +7193,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_class_sig_item x
                   in Ast.CgSem (_loc, x, (cgSem_of_list xs))
-              
+
             let rec crSem_of_list =
               function
               | [] -> Ast.CrNil ghost
@@ -7191,7 +7201,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_class_str_item x
                   in Ast.CrSem (_loc, x, (crSem_of_list xs))
-              
+
             let rec paSem_of_list =
               function
               | [] -> Ast.PaNil ghost
@@ -7199,7 +7209,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_patt x
                   in Ast.PaSem (_loc, x, (paSem_of_list xs))
-              
+
             let rec paCom_of_list =
               function
               | [] -> Ast.PaNil ghost
@@ -7207,7 +7217,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_patt x
                   in Ast.PaCom (_loc, x, (paCom_of_list xs))
-              
+
             let rec exSem_of_list =
               function
               | [] -> Ast.ExNil ghost
@@ -7215,7 +7225,7 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_expr x
                   in Ast.ExSem (_loc, x, (exSem_of_list xs))
-              
+
             let rec exCom_of_list =
               function
               | [] -> Ast.ExNil ghost
@@ -7223,14 +7233,14 @@ module Struct =
               | x :: xs ->
                   let _loc = loc_of_expr x
                   in Ast.ExCom (_loc, x, (exCom_of_list xs))
-              
+
             let ty_of_stl =
               function
               | (_loc, s, []) -> Ast.TyId (_loc, (Ast.IdUid (_loc, s)))
               | (_loc, s, tl) ->
                   Ast.TyOf (_loc, (Ast.TyId (_loc, (Ast.IdUid (_loc, s)))),
                     (tyAnd_of_list tl))
-              
+
             let ty_of_sbt =
               function
               | (_loc, s, true, t) ->
@@ -7239,41 +7249,41 @@ module Struct =
               | (_loc, s, false, t) ->
                   Ast.TyCol (_loc, (Ast.TyId (_loc, (Ast.IdLid (_loc, s)))),
                     t)
-              
+
             let bi_of_pe (p, e) =
               let _loc = loc_of_patt p in Ast.BiEq (_loc, p, e)
-              
+
             let sum_type_of_list l = tyOr_of_list (List.map ty_of_stl l)
-              
+
             let record_type_of_list l = tySem_of_list (List.map ty_of_sbt l)
-              
+
             let binding_of_pel l = biAnd_of_list (List.map bi_of_pe l)
-              
+
             let rec pel_of_binding =
               function
               | Ast.BiAnd (_, b1, b2) ->
                   (pel_of_binding b1) @ (pel_of_binding b2)
               | Ast.BiEq (_, p, e) -> [ (p, e) ]
               | _ -> assert false
-              
+
             let rec list_of_binding x acc =
               match x with
               | Ast.BiAnd (_, b1, b2) ->
                   list_of_binding b1 (list_of_binding b2 acc)
               | t -> t :: acc
-              
+
             let rec list_of_rec_binding x acc =
               match x with
               | Ast.RbSem (_, b1, b2) ->
                   list_of_rec_binding b1 (list_of_rec_binding b2 acc)
               | t -> t :: acc
-              
+
             let rec list_of_with_constr x acc =
               match x with
               | Ast.WcAnd (_, w1, w2) ->
                   list_of_with_constr w1 (list_of_with_constr w2 acc)
               | t -> t :: acc
-              
+
             let rec list_of_ctyp x acc =
               match x with
               | Ast.TyNil _ -> acc
@@ -7282,96 +7292,96 @@ module Struct =
                   Ast.TyAnd (_, x, y) | Ast.TyOr (_, x, y) ->
                   list_of_ctyp x (list_of_ctyp y acc)
               | x -> x :: acc
-              
+
             let rec list_of_patt x acc =
               match x with
               | Ast.PaNil _ -> acc
               | Ast.PaCom (_, x, y) | Ast.PaSem (_, x, y) ->
                   list_of_patt x (list_of_patt y acc)
               | x -> x :: acc
-              
+
             let rec list_of_expr x acc =
               match x with
               | Ast.ExNil _ -> acc
               | Ast.ExCom (_, x, y) | Ast.ExSem (_, x, y) ->
                   list_of_expr x (list_of_expr y acc)
               | x -> x :: acc
-              
+
             let rec list_of_str_item x acc =
               match x with
               | Ast.StNil _ -> acc
               | Ast.StSem (_, x, y) ->
                   list_of_str_item x (list_of_str_item y acc)
               | x -> x :: acc
-              
+
             let rec list_of_sig_item x acc =
               match x with
               | Ast.SgNil _ -> acc
               | Ast.SgSem (_, x, y) ->
                   list_of_sig_item x (list_of_sig_item y acc)
               | x -> x :: acc
-              
+
             let rec list_of_class_sig_item x acc =
               match x with
               | Ast.CgNil _ -> acc
               | Ast.CgSem (_, x, y) ->
                   list_of_class_sig_item x (list_of_class_sig_item y acc)
               | x -> x :: acc
-              
+
             let rec list_of_class_str_item x acc =
               match x with
               | Ast.CrNil _ -> acc
               | Ast.CrSem (_, x, y) ->
                   list_of_class_str_item x (list_of_class_str_item y acc)
               | x -> x :: acc
-              
+
             let rec list_of_class_type x acc =
               match x with
               | Ast.CtAnd (_, x, y) ->
                   list_of_class_type x (list_of_class_type y acc)
               | x -> x :: acc
-              
+
             let rec list_of_class_expr x acc =
               match x with
               | Ast.CeAnd (_, x, y) ->
                   list_of_class_expr x (list_of_class_expr y acc)
               | x -> x :: acc
-              
+
             let rec list_of_module_expr x acc =
               match x with
               | Ast.MeApp (_, x, y) ->
                   list_of_module_expr x (list_of_module_expr y acc)
               | x -> x :: acc
-              
+
             let rec list_of_match_case x acc =
               match x with
               | Ast.McNil _ -> acc
               | Ast.McOr (_, x, y) ->
                   list_of_match_case x (list_of_match_case y acc)
               | x -> x :: acc
-              
+
             let rec list_of_ident x acc =
               match x with
               | Ast.IdAcc (_, x, y) | Ast.IdApp (_, x, y) ->
                   list_of_ident x (list_of_ident y acc)
               | x -> x :: acc
-              
+
             let rec list_of_module_binding x acc =
               match x with
               | Ast.MbAnd (_, x, y) ->
                   list_of_module_binding x (list_of_module_binding y acc)
               | x -> x :: acc
-              
+
             module Meta =
               struct
                 module type META_LOC =
                   sig
                     val meta_loc_patt : Loc.t -> Loc.t -> Ast.patt
-                      
+
                     val meta_loc_expr : Loc.t -> Loc.t -> Ast.expr
-                      
+
                   end
-                  
+
                 module MetaLoc =
                   struct
                     let meta_loc_patt _loc location =
@@ -7408,7 +7418,7 @@ module Struct =
                                     else
                                       Ast.PaId (_loc,
                                         (Ast.IdUid (_loc, "False")))))))))))
-                      
+
                     let meta_loc_expr _loc location =
                       let (a, b, c, d, e, f, g, h) = Loc.to_tuple location
                       in
@@ -7443,58 +7453,58 @@ module Struct =
                                     else
                                       Ast.ExId (_loc,
                                         (Ast.IdUid (_loc, "False")))))))))))
-                      
+
                   end
-                  
+
                 module MetaGhostLoc =
                   struct
                     let meta_loc_patt _loc _ =
                       Ast.PaId (_loc,
                         (Ast.IdAcc (_loc, (Ast.IdUid (_loc, "Loc")),
                            (Ast.IdLid (_loc, "ghost")))))
-                      
+
                     let meta_loc_expr _loc _ =
                       Ast.ExId (_loc,
                         (Ast.IdAcc (_loc, (Ast.IdUid (_loc, "Loc")),
                            (Ast.IdLid (_loc, "ghost")))))
-                      
+
                   end
-                  
+
                 module MetaLocVar =
                   struct
                     let meta_loc_patt _loc _ =
                       Ast.PaId (_loc, (Ast.IdLid (_loc, !Loc.name)))
-                      
+
                     let meta_loc_expr _loc _ =
                       Ast.ExId (_loc, (Ast.IdLid (_loc, !Loc.name)))
-                      
+
                   end
-                  
+
                 module Make (MetaLoc : META_LOC) =
                   struct
                     open MetaLoc
-                      
+
                     let meta_loc = meta_loc_expr
-                      
+
                     module Expr =
                       struct
                         let meta_string _loc s =
                           Ast.ExStr (_loc, (safe_string_escaped s))
-                          
+
                         let meta_int _loc s = Ast.ExInt (_loc, s)
-                          
+
                         let meta_float _loc s = Ast.ExFlo (_loc, s)
-                          
+
                         let meta_char _loc s =
                           Ast.ExChr (_loc, (String.escaped s))
-                          
+
                         let meta_bool _loc =
                           function
                           | false ->
                               Ast.ExId (_loc, (Ast.IdUid (_loc, "False")))
                           | true ->
                               Ast.ExId (_loc, (Ast.IdUid (_loc, "True")))
-                          
+
                         let rec meta_list mf_a _loc =
                           function
                           | [] -> Ast.ExId (_loc, (Ast.IdUid (_loc, "[]")))
@@ -7504,7 +7514,7 @@ module Struct =
                                    (Ast.ExId (_loc, (Ast.IdUid (_loc, "::")))),
                                    (mf_a _loc x))),
                                 (meta_list mf_a _loc xs))
-                          
+
                         let rec meta_binding _loc =
                           function
                           | Ast.BiAnt (x0, x1) -> Ast.ExAnt (x0, x1)
@@ -9908,30 +9918,30 @@ module Struct =
                                       (Ast.IdUid (_loc, "Ast")),
                                       (Ast.IdUid (_loc, "WcNil")))))),
                                 (meta_loc _loc x0))
-                          
+
                       end
-                      
+
                     let meta_loc = meta_loc_patt
-                      
+
                     module Patt =
                       struct
                         let meta_string _loc s =
                           Ast.PaStr (_loc, (safe_string_escaped s))
-                          
+
                         let meta_int _loc s = Ast.PaInt (_loc, s)
-                          
+
                         let meta_float _loc s = Ast.PaFlo (_loc, s)
-                          
+
                         let meta_char _loc s =
                           Ast.PaChr (_loc, (String.escaped s))
-                          
+
                         let meta_bool _loc =
                           function
                           | false ->
                               Ast.PaId (_loc, (Ast.IdUid (_loc, "False")))
                           | true ->
                               Ast.PaId (_loc, (Ast.IdUid (_loc, "True")))
-                          
+
                         let rec meta_list mf_a _loc =
                           function
                           | [] -> Ast.PaId (_loc, (Ast.IdUid (_loc, "[]")))
@@ -9941,7 +9951,7 @@ module Struct =
                                    (Ast.PaId (_loc, (Ast.IdUid (_loc, "::")))),
                                    (mf_a _loc x))),
                                 (meta_list mf_a _loc xs))
-                          
+
                         let rec meta_binding _loc =
                           function
                           | Ast.BiAnt (x0, x1) -> Ast.PaAnt (x0, x1)
@@ -12345,13 +12355,13 @@ module Struct =
                                       (Ast.IdUid (_loc, "Ast")),
                                       (Ast.IdUid (_loc, "WcNil")))))),
                                 (meta_loc _loc x0))
-                          
+
                       end
-                      
+
                   end
-                  
+
               end
-              
+
             class map =
               object ((o : 'self_type))
                 method string : string -> string = o#unknown
@@ -13353,7 +13363,7 @@ module Struct =
                       let _x_i1 = o#string _x_i1 in BiAnt (_x, _x_i1)
                 method unknown : 'a. 'a -> 'a = fun x -> x
               end
-              
+
             class fold =
               object ((o : 'self_type))
                 method string : string -> 'self_type = o#unknown
@@ -14126,53 +14136,53 @@ module Struct =
                       let o = o#loc _x in let o = o#string _x_i1 in o
                 method unknown : 'a. 'a -> 'self_type = fun _ -> o
               end
-              
+
             let map_expr f =
               object
                 inherit map as super
                 method expr = fun x -> f (super#expr x)
               end
-              
+
             let map_patt f =
               object
                 inherit map as super
                 method patt = fun x -> f (super#patt x)
               end
-              
+
             let map_ctyp f =
               object
                 inherit map as super
                 method ctyp = fun x -> f (super#ctyp x)
               end
-              
+
             let map_str_item f =
               object
                 inherit map as super
                 method str_item = fun x -> f (super#str_item x)
               end
-              
+
             let map_sig_item f =
               object
                 inherit map as super
                 method sig_item = fun x -> f (super#sig_item x)
               end
-              
+
             let map_loc f =
               object
                 inherit map as super
                 method loc = fun x -> f (super#loc x)
               end
-              
+
           end
-          
+
       end
-      
+
     module DynAst =
       struct
         module Make (Ast : Sig.Ast) : Sig.DynAst with module Ast = Ast =
           struct
             module Ast = Ast
-              
+
             type 'a tag =
               | Tag_ctyp
               | Tag_patt
@@ -14191,7 +14201,7 @@ module Struct =
               | Tag_binding
               | Tag_rec_binding
               | Tag_module_binding
-            
+
             let string_of_tag =
               function
               | Tag_ctyp -> "ctyp"
@@ -14211,112 +14221,112 @@ module Struct =
               | Tag_binding -> "binding"
               | Tag_rec_binding -> "rec_binding"
               | Tag_module_binding -> "module_binding"
-              
+
             let ctyp_tag = Tag_ctyp
-              
+
             let patt_tag = Tag_patt
-              
+
             let expr_tag = Tag_expr
-              
+
             let module_type_tag = Tag_module_type
-              
+
             let sig_item_tag = Tag_sig_item
-              
+
             let with_constr_tag = Tag_with_constr
-              
+
             let module_expr_tag = Tag_module_expr
-              
+
             let str_item_tag = Tag_str_item
-              
+
             let class_type_tag = Tag_class_type
-              
+
             let class_sig_item_tag = Tag_class_sig_item
-              
+
             let class_expr_tag = Tag_class_expr
-              
+
             let class_str_item_tag = Tag_class_str_item
-              
+
             let match_case_tag = Tag_match_case
-              
+
             let ident_tag = Tag_ident
-              
+
             let binding_tag = Tag_binding
-              
+
             let rec_binding_tag = Tag_rec_binding
-              
+
             let module_binding_tag = Tag_module_binding
-              
+
             type dyn
-            
+
             external dyn_tag : 'a tag -> dyn tag = "%identity"
-              
+
             module Pack (X : sig type 'a t
                                   end) =
               struct
                 type pack = ((dyn tag) * Obj.t)
-                
+
                 exception Pack_error
-                  
+
                 let pack tag v = ((dyn_tag tag), (Obj.repr v))
-                  
+
                 let unpack (tag : 'a tag) (tag', obj) =
                   if (dyn_tag tag) = tag'
                   then (Obj.obj obj : 'a X.t)
                   else raise Pack_error
-                  
+
                 let print_tag f (tag, _) =
                   Format.pp_print_string f (string_of_tag tag)
-                  
+
               end
-              
+
           end
-          
+
       end
-      
+
     module Quotation =
       struct
         module Make (Ast : Sig.Camlp4Ast) :
           Sig.Quotation with module Ast = Ast =
           struct
             module Ast = Ast
-              
+
             module DynAst = DynAst.Make(Ast)
-              
+
             module Loc = Ast.Loc
-              
+
             open Format
-              
+
             open Sig
-              
+
             type 'a expand_fun = Loc.t -> string option -> string -> 'a
-            
+
             module Exp_key = DynAst.Pack(struct type 'a t = unit
                                                  end)
-              
+
             module Exp_fun =
               DynAst.Pack(struct type 'a t = 'a expand_fun
                                   end)
-              
+
             let expanders_table :
               (((string * Exp_key.pack) * Exp_fun.pack) list) ref = ref []
-              
+
             let default = ref ""
-              
+
             let translate = ref (fun x -> x)
-              
+
             let expander_name name =
               match !translate name with | "" -> !default | name -> name
-              
+
             let find name tag =
               let key = ((expander_name name), (Exp_key.pack tag ()))
               in Exp_fun.unpack tag (List.assoc key !expanders_table)
-              
+
             let add name tag f =
               let elt = ((name, (Exp_key.pack tag ())), (Exp_fun.pack tag f))
               in expanders_table := elt :: !expanders_table
-              
+
             let dump_file = ref None
-              
+
             module Error =
               struct
                 type error =
@@ -14324,11 +14334,11 @@ module Struct =
                   | Expanding
                   | ParsingResult of Loc.t * string
                   | Locating
-                
+
                 type t = (string * string * error * exn)
-                
+
                 exception E of t
-                  
+
                 let print ppf (name, position, ctx, exn) =
                   let name = if name = "" then !default else name in
                   let pp x =
@@ -14379,17 +14389,17 @@ module Struct =
                                fprintf ppf
                                  "\n(consider setting variable Quotation.dump_file, or using the -QD option)")
                   in fprintf ppf "@\n%a@]@." ErrorHandler.print exn
-                  
+
                 let to_string x =
                   let b = Buffer.create 50 in
                   let () = bprintf b "%a" print x in Buffer.contents b
-                  
+
               end
-              
+
             let _ = let module M = ErrorHandler.Register(Error) in ()
-              
+
             open Error
-              
+
             let expand_quotation loc expander pos_tag quot =
               let loc_name_opt =
                 if quot.q_loc = "" then None else Some quot.q_loc
@@ -14404,7 +14414,7 @@ module Struct =
                     let exc1 =
                       Error.E (((quot.q_name), pos_tag, Expanding, exc))
                     in raise (Loc.Exc_located (loc, exc1))
-              
+
             let parse_quotation_result parse loc quot pos_tag str =
               try parse loc str
               with
@@ -14419,7 +14429,7 @@ module Struct =
                   let ctx = ParsingResult (iloc, quot.q_contents) in
                   let exc1 = Error.E (((quot.q_name), pos_tag, ctx, exc))
                   in raise (Loc.Exc_located (iloc, exc1))
-              
+
             let expand loc quotation tag =
               let pos_tag = DynAst.string_of_tag tag in
               let name = quotation.q_name in
@@ -14436,56 +14446,56 @@ module Struct =
                          (Error.E ((name, pos_tag, Finding, exc))))) in
               let loc = Loc.join (Loc.move `start quotation.q_shift loc)
               in expand_quotation loc expander pos_tag quotation
-              
+
           end
-          
+
       end
-      
+
     module AstFilters =
       struct
         module Make (Ast : Sig.Camlp4Ast) :
           Sig.AstFilters with module Ast = Ast =
           struct
             module Ast = Ast
-              
+
             type 'a filter = 'a -> 'a
-            
+
             let interf_filters = Queue.create ()
-              
+
             let fold_interf_filters f i = Queue.fold f i interf_filters
-              
+
             let implem_filters = Queue.create ()
-              
+
             let fold_implem_filters f i = Queue.fold f i implem_filters
-              
+
             let topphrase_filters = Queue.create ()
-              
+
             let fold_topphrase_filters f i = Queue.fold f i topphrase_filters
-              
+
             let register_sig_item_filter f = Queue.add f interf_filters
-              
+
             let register_str_item_filter f = Queue.add f implem_filters
-              
+
             let register_topphrase_filter f = Queue.add f topphrase_filters
-              
+
           end
-          
+
       end
-      
+
     module Camlp4Ast2OCamlAst :
       sig
         module Make (Camlp4Ast : Sig.Camlp4Ast) :
           sig
             open Camlp4Ast
-              
+
             val sig_item : sig_item -> Parsetree.signature
-              
+
             val str_item : str_item -> Parsetree.structure
-              
+
             val phrase : str_item -> Parsetree.toplevel_phrase
-              
+
           end
-          
+
       end =
       struct
         module Location =
@@ -14495,9 +14505,9 @@ module Struct =
                 { loc_start : Lexing.position; loc_end : Lexing.position;
                   loc_ghost : bool
                 }
-            
+
             type 'a loc = ('a Location.loc) = { txt : 'a; loc : t }
-            
+
             let none =
               let loc =
                 {
@@ -14507,47 +14517,47 @@ module Struct =
                   pos_cnum = (-1);
                 }
               in { loc_start = loc; loc_end = loc; loc_ghost = true; }
-              
+
             let mkloc txt loc = { txt = txt; loc = loc; }
-              
+
           end
-          
+
         module Longident =
           struct
             type t =
               Longident.t =
                 | Lident of string | Ldot of t * string | Lapply of t * t
-            
+
             let last =
               function
               | Lident s -> s
               | Ldot (_, s) -> s
               | Lapply (_, _) -> failwith "Longident.last"
-              
+
           end
-          
+
         module Make (Ast : Sig.Camlp4Ast) =
           struct
             open Format
-              
+
             open Parsetree
-              
+
             open Longident
-              
+
             open Asttypes
-              
+
             open Ast
-              
+
             let error loc str = Loc.raise loc (Failure str)
-              
+
             let char_of_char_token loc s =
               try Token.Eval.char s
               with | (Failure _ as exn) -> Loc.raise loc exn
-              
+
             let string_of_string_token loc s =
               try Token.Eval.string s
               with | (Failure _ as exn) -> Loc.raise loc exn
-              
+
             let remove_underscores s =
               let l = String.length s in
               let rec remove src dst =
@@ -14558,73 +14568,73 @@ module Struct =
                    | '_' -> remove (src + 1) dst
                    | c -> (Bytes.set s dst c; remove (src + 1) (dst + 1)))
               in remove 0 0
-              
+
             let mkloc = Loc.to_ocaml_location
-              
+
             let mkghloc loc = Loc.to_ocaml_location (Loc.ghostify loc)
-              
+
             let with_loc txt loc = Location.mkloc txt (mkloc loc)
-              
+
             let mktyp loc d =
               { ptyp_desc = d; ptyp_loc = mkloc loc; ptyp_attributes = []; }
-              
+
             let mkpat loc d =
               { ppat_desc = d; ppat_loc = mkloc loc; ppat_attributes = []; }
-              
+
             let mkghpat loc d =
               { ppat_desc = d; ppat_loc = mkghloc loc; ppat_attributes = [];
               }
-              
+
             let mkexp loc d =
               { pexp_desc = d; pexp_loc = mkloc loc; pexp_attributes = []; }
-              
+
             let mkmty loc d =
               { pmty_desc = d; pmty_loc = mkloc loc; pmty_attributes = []; }
-              
+
             let mksig loc d = { psig_desc = d; psig_loc = mkloc loc; }
-              
+
             let mkmod loc d =
               { pmod_desc = d; pmod_loc = mkloc loc; pmod_attributes = []; }
-              
+
             let mkstr loc d = { pstr_desc = d; pstr_loc = mkloc loc; }
-              
+
             let mkcty loc d =
               { pcty_desc = d; pcty_loc = mkloc loc; pcty_attributes = []; }
-              
+
             let mkcl loc d =
               { pcl_desc = d; pcl_loc = mkloc loc; pcl_attributes = []; }
-              
+
             let mkcf loc d =
               { pcf_desc = d; pcf_loc = mkloc loc; pcf_attributes = []; }
-              
+
             let mkctf loc d =
               { pctf_desc = d; pctf_loc = mkloc loc; pctf_attributes = []; }
-              
+
             let mkpolytype t =
               match t.ptyp_desc with
               | Ptyp_poly (_, _) -> t
               | _ -> { (t) with ptyp_desc = Ptyp_poly ([], t); }
-              
+
             let mkvirtual =
               function
               | Ast.ViVirtual -> Virtual
               | Ast.ViNil -> Concrete
               | _ -> assert false
-              
+
             let mkdirection =
               function
               | Ast.DiTo -> Upto
               | Ast.DiDownto -> Downto
               | _ -> assert false
-              
+
             let lident s = Lident s
-              
+
             let lident_with_loc s loc = with_loc (Lident s) loc
-              
+
             let ldot l s = Ldot (l, s)
-              
+
             let lapply l s = Lapply (l, s)
-              
+
             let conv_con =
               let t = Hashtbl.create 73
               in
@@ -14632,37 +14642,37 @@ module Struct =
                    [ ("True", "true"); ("False", "false"); (" True", "True");
                      (" False", "False") ];
                  fun s -> try Hashtbl.find t s with | Not_found -> s)
-              
+
             let conv_lab =
               let t = Hashtbl.create 73
               in
                 (List.iter (fun (s, s') -> Hashtbl.add t s s')
                    [ ("val", "contents") ];
                  fun s -> try Hashtbl.find t s with | Not_found -> s)
-              
+
             let array_function_no_loc str name =
               ldot (lident str)
                 (if !Camlp4_config.unsafe then "unsafe_" ^ name else name)
-              
+
             let array_function loc str name =
               with_loc (array_function_no_loc str name) loc
-              
+
             let mkrf =
               function
               | Ast.ReRecursive -> Recursive
               | Ast.ReNil -> Nonrecursive
               | _ -> assert false
-              
+
             let mkli sloc s list =
               let rec loop f =
                 function | i :: il -> loop (ldot (f i)) il | [] -> f s
               in with_loc (loop lident list) sloc
-              
+
             let rec ctyp_fa al =
               function
               | TyApp (_, f, a) -> ctyp_fa (a :: al) f
               | f -> (f, al)
-              
+
             let ident_tag ?(conv_lid = fun x -> x) i =
               let rec self i acc =
                 match i with
@@ -14698,31 +14708,31 @@ module Struct =
                     in (x, `lident)
                 | _ -> error (loc_of_ident i) "invalid long identifier"
               in self i None
-              
+
             let ident_noloc ?conv_lid i = fst (ident_tag ?conv_lid i)
-              
+
             let ident ?conv_lid i =
               with_loc (ident_noloc ?conv_lid i) (loc_of_ident i)
-              
+
             let long_lident msg id =
               match ident_tag id with
               | (i, `lident) -> with_loc i (loc_of_ident id)
               | _ -> error (loc_of_ident id) msg
-              
+
             let long_type_ident = long_lident "invalid long identifier type"
-              
+
             let long_class_ident = long_lident "invalid class name"
-              
+
             let long_uident_noloc ?(conv_con = fun x -> x) i =
               match ident_tag i with
               | (Ldot (i, s), `uident) -> ldot i (conv_con s)
               | (Lident s, `uident) -> lident (conv_con s)
               | (i, `app) -> i
               | _ -> error (loc_of_ident i) "uppercase identifier expected"
-              
+
             let long_uident ?conv_con i =
               with_loc (long_uident_noloc ?conv_con i) (loc_of_ident i)
-              
+
             let rec ctyp_long_id_prefix t =
               match t with
               | Ast.TyId (_, i) -> ident_noloc i
@@ -14730,32 +14740,32 @@ module Struct =
                   let li1 = ctyp_long_id_prefix m1 in
                   let li2 = ctyp_long_id_prefix m2 in Lapply (li1, li2)
               | t -> error (loc_of_ctyp t) "invalid module expression"
-              
+
             let ctyp_long_id t =
               match t with
               | Ast.TyId (_, i) -> (false, (long_type_ident i))
               | TyApp (loc, _, _) -> error loc "invalid type name"
               | TyCls (_, i) -> (true, (ident i))
               | t -> error (loc_of_ctyp t) "invalid type"
-              
+
             let rec ty_var_list_of_ctyp =
               function
               | Ast.TyApp (_, t1, t2) ->
                   (ty_var_list_of_ctyp t1) @ (ty_var_list_of_ctyp t2)
               | Ast.TyQuo (_, s) -> [ s ]
               | _ -> assert false
-              
+
             let predef_option loc =
               TyId
                 ((loc,
                   (IdAcc
                      ((loc, (IdLid ((loc, "*predef*"))),
                        (IdLid ((loc, "option"))))))))
-              
+
             let attribute_fwd = ref (fun _ _ _ -> assert false)
-              
+
             let attribute loc s str = !attribute_fwd loc s str
-              
+
             let rec ctyp =
               function
               | TyId (loc, i) ->
@@ -14777,14 +14787,14 @@ module Struct =
                     then mktyp loc (Ptyp_class (li, (List.map ctyp al)))
                     else mktyp loc (Ptyp_constr (li, (List.map ctyp al)))
               | TyArr (loc, (TyLab (_, lab, t1)), t2) ->
-                  mktyp loc (Ptyp_arrow (lab, (ctyp t1), (ctyp t2)))
+                  mktyp loc (Ptyp_arrow (parr lab, (ctyp t1), (ctyp t2)))
               | TyArr (loc, (TyOlb (loc1, lab, t1)), t2) ->
                   let t1 = TyApp (loc1, (predef_option loc1), t1)
                   in
                     mktyp loc
-                      (Ptyp_arrow (("?" ^ lab), (ctyp t1), (ctyp t2)))
+                      (Ptyp_arrow (Parr_optional lab, (ctyp t1), (ctyp t2)))
               | TyArr (loc, t1, t2) ->
-                  mktyp loc (Ptyp_arrow ("", (ctyp t1), (ctyp t2)))
+                  mktyp loc (Ptyp_arrow (Parr_simple, (ctyp t1), (ctyp t2)))
               | Ast.TyObj (loc, fl, Ast.RvNil) ->
                   mktyp loc (Ptyp_object ((meth_list fl []), Closed))
               | Ast.TyObj (loc, fl, Ast.RvRowVar) ->
@@ -14889,7 +14899,7 @@ module Struct =
                   ((long_uident i), (package_type_constraints wc []))
               | Ast.MtId (_, i) -> ((long_uident i), [])
               | mt -> error (loc_of_module_type mt) "unexpected package type"
-              
+
             let mktype loc name tl cl tk tp tm =
               {
                 ptype_name = name;
@@ -14901,15 +14911,15 @@ module Struct =
                 ptype_loc = mkloc loc;
                 ptype_attributes = [];
               }
-              
+
             let mkprivate' m = if m then Private else Public
-              
+
             let mkprivate =
               function
               | Ast.PrPrivate -> Private
               | Ast.PrNil -> Public
               | _ -> assert false
-              
+
             let mktrecord =
               function
               | Ast.TyCol (loc, (Ast.TyId (_, (Ast.IdLid (sloc, s)))),
@@ -14930,7 +14940,7 @@ module Struct =
                     pld_attributes = [];
                   }
               | _ -> assert false
-              
+
             let mkvariant =
               function
               | Ast.TyId (loc, (Ast.IdUid (sloc, s))) ->
@@ -14967,7 +14977,7 @@ module Struct =
                     pcd_attributes = [];
                   }
               | _ -> assert false
-              
+
             let rec type_decl name tl cl loc m pflag =
               function
               | Ast.TyMan (_, t1, t2) ->
@@ -14998,10 +15008,10 @@ module Struct =
                      in
                        mktype loc name tl cl Ptype_abstract
                          (mkprivate' pflag) m)
-              
+
             let type_decl name tl cl t loc =
               type_decl name tl cl loc None false t
-              
+
             let mkvalue_desc loc name t p =
               {
                 pval_name = name;
@@ -15010,19 +15020,19 @@ module Struct =
                 pval_loc = mkloc loc;
                 pval_attributes = [];
               }
-              
+
             let rec list_of_meta_list =
               function
               | Ast.LNil -> []
               | Ast.LCons (x, xs) -> x :: (list_of_meta_list xs)
               | Ast.LAnt _ -> assert false
-              
+
             let mkmutable =
               function
               | Ast.MuMutable -> Mutable
               | Ast.MuNil -> Immutable
               | _ -> assert false
-              
+
             let paolab lab p =
               match (lab, p) with
               | ("",
@@ -15031,12 +15041,12 @@ module Struct =
                   -> i
               | ("", p) -> error (loc_of_patt p) "bad ast in label"
               | _ -> lab
-              
+
             let opt_private_ctyp =
               function
               | Ast.TyPrv (_, t) -> (Ptype_abstract, Private, (ctyp t))
               | t -> (Ptype_abstract, Public, (ctyp t))
-              
+
             let rec type_parameters t acc =
               match t with
               | Ast.TyApp (_, t1, t2) ->
@@ -15045,14 +15055,14 @@ module Struct =
               | Ast.TyQuM (_, s) -> (s, Contravariant) :: acc
               | Ast.TyQuo (_, s) -> (s, Invariant) :: acc
               | _ -> assert false
-              
+
             let core_type loc ty =
               { ptyp_desc = ty; ptyp_loc = mkloc loc; ptyp_attributes = []; }
-              
+
             let ptyp_var loc s = core_type loc (Ptyp_var s)
-              
+
             let ptyp_any loc = core_type loc Ptyp_any
-              
+
             let rec optional_type_parameters t acc =
               match t with
               | Ast.TyApp (_, t1, t2) ->
@@ -15066,7 +15076,7 @@ module Struct =
               | Ast.TyQuo (loc, s) -> ((ptyp_var loc s), Invariant) :: acc
               | Ast.TyAny loc -> ((ptyp_any loc), Invariant) :: acc
               | _ -> assert false
-              
+
             let rec class_parameters t acc =
               match t with
               | Ast.TyCom (_, t1, t2) ->
@@ -15076,7 +15086,7 @@ module Struct =
                   ((ptyp_var loc s), Contravariant) :: acc
               | Ast.TyQuo (loc, s) -> ((ptyp_var loc s), Invariant) :: acc
               | _ -> assert false
-              
+
             let rec type_parameters_and_type_name t acc =
               match t with
               | Ast.TyApp (_, t1, t2) ->
@@ -15084,7 +15094,7 @@ module Struct =
                     (optional_type_parameters t2 acc)
               | Ast.TyId (_, i) -> ((ident i), acc)
               | _ -> assert false
-              
+
             let mkwithtyp pwith_type loc id_tpl ct =
               let (id, tpl) = type_parameters_and_type_name id_tpl [] in
               let (kind, priv, ct) = opt_private_ctyp ct
@@ -15101,7 +15111,7 @@ module Struct =
                     ptype_loc = mkloc loc;
                     ptype_attributes = [];
                   }
-              
+
             let rec mkwithc wc acc =
               match wc with
               | Ast.WcNil _ -> acc
@@ -15123,12 +15133,12 @@ module Struct =
               | Ast.WcAnd (_, wc1, wc2) -> mkwithc wc1 (mkwithc wc2 acc)
               | Ast.WcAnt (loc, _) ->
                   error loc "bad with constraint (antiquotation)"
-              
+
             let rec patt_fa al =
               function
               | PaApp (_, f, a) -> patt_fa (a :: al) f
               | f -> (f, al)
-              
+
             let rec deep_mkrangepat loc c1 c2 =
               if c1 = c2
               then mkghpat loc (Ppat_constant (Const_char c1))
@@ -15136,7 +15146,7 @@ module Struct =
                 mkghpat loc
                   (Ppat_or ((mkghpat loc (Ppat_constant (Const_char c1))),
                      (deep_mkrangepat loc (Char.chr ((Char.code c1) + 1)) c2)))
-              
+
             let rec mkrangepat loc c1 c2 =
               if c1 > c2
               then mkrangepat loc c2 c1
@@ -15148,7 +15158,7 @@ module Struct =
                     (Ppat_or ((mkghpat loc (Ppat_constant (Const_char c1))),
                        (deep_mkrangepat loc (Char.chr ((Char.code c1) + 1))
                           c2)))
-              
+
             let rec patt =
               function
               | Ast.PaId (loc, (Ast.IdLid (sloc, s))) ->
@@ -15287,17 +15297,17 @@ module Struct =
               | Ast.PaEq (_, i, p) ->
                   ((ident ~conv_lid: conv_lab i), (patt p))
               | p -> error (loc_of_patt p) "invalid pattern"
-              
+
             let rec expr_fa al =
               function
               | ExApp (_, f, a) -> expr_fa (a :: al) f
               | f -> (f, al)
-              
+
             let rec class_expr_fa al =
               function
               | CeApp (_, ce, a) -> class_expr_fa (a :: al) ce
               | ce -> (ce, al)
-              
+
             let rec sep_expr_acc l =
               function
               | ExAcc (_, e1, e2) -> sep_expr_acc (sep_expr_acc l e2) e1
@@ -15320,16 +15330,16 @@ module Struct =
                         as i) -> Ast.ExId (_loc, i))
                   in sep_expr_acc l (normalize_acc i)
               | e -> ((loc_of_expr e), [], e) :: l
-              
+
             let override_flag loc =
               function
               | Ast.OvOverride -> Override
               | Ast.OvNil -> Fresh
               | _ -> error loc "antiquotation not allowed here"
-              
+
             let list_of_opt_ctyp ot acc =
               match ot with | Ast.TyNil _ -> acc | t -> list_of_ctyp t acc
-              
+
             let varify_constructors var_names =
               let rec loop t =
                 let desc =
@@ -15369,14 +15379,14 @@ module Struct =
                     Rtag ((label, attrs, flag, (List.map loop lst)))
                 | Rinherit t -> Rinherit (loop t)
               in loop
-              
+
             let rec expr =
               function
               | Ast.ExAcc (loc, x, (Ast.ExId (_, (Ast.IdLid (_, "val"))))) ->
                   mkexp loc
                     (Pexp_apply
                        ((mkexp loc (Pexp_ident (lident_with_loc "!" loc))),
-                       [ ("", (expr x)) ]))
+                       [ (Papp_simple, (expr x)) ]))
               | (ExAcc (loc, _, _) | Ast.ExId (loc, (Ast.IdAcc (_, _, _))) as
                  e) ->
                   let (e, l) =
@@ -15432,7 +15442,7 @@ module Struct =
                     (Pexp_apply
                        ((mkexp loc
                            (Pexp_ident (array_function loc "Array" "get"))),
-                       [ ("", (expr e1)); ("", (expr e2)) ]))
+                       [ (Papp_simple, (expr e1)); (Papp_simple, (expr e2)) ]))
               | ExArr (loc, e) ->
                   mkexp loc (Pexp_array (List.map expr (list_of_expr e [])))
               | ExAsf loc ->
@@ -15450,7 +15460,7 @@ module Struct =
                          Pexp_apply
                            ((mkexp loc
                                (Pexp_ident (lident_with_loc ":=" loc))),
-                           [ ("", (expr x)); ("", (expr v)) ])
+                           [ (Papp_simple, (expr x)); (Papp_simple, (expr v)) ])
                      | ExAcc (loc, _, _) ->
                          (match (expr e).pexp_desc with
                           | Pexp_field (e, lab) ->
@@ -15460,7 +15470,7 @@ module Struct =
                          Pexp_apply
                            ((mkexp loc
                                (Pexp_ident (array_function loc "Array" "set"))),
-                           [ ("", (expr e1)); ("", (expr e2)); ("", (expr v)) ])
+                           [ (Papp_simple, (expr e1)); (Papp_simple, (expr e2)); (Papp_simple, (expr v)) ])
                      | Ast.ExId (_, (Ast.IdLid (lloc, lab))) ->
                          Pexp_setinstvar ((with_loc lab lloc), (expr v))
                      | ExSte (loc, e1, e2) ->
@@ -15468,7 +15478,7 @@ module Struct =
                            ((mkexp loc
                                (Pexp_ident
                                   (array_function loc "String" "set"))),
-                           [ ("", (expr e1)); ("", (expr e2)); ("", (expr v)) ])
+                           [ (Papp_simple, (expr e1)); (Papp_simple, (expr e2)); (Papp_simple, (expr v)) ])
                      | _ -> error loc "bad left part of assignment")
                   in mkexp loc e
               | ExAsr (loc, e) -> mkexp loc (Pexp_assert (expr e))
@@ -15540,9 +15550,15 @@ module Struct =
               | ExLet (loc, rf, bi, e) ->
                   mkexp loc (Pexp_let ((mkrf rf), (binding bi []), (expr e)))
               | ExLmd (loc, i, me, e) ->
+                  let mb = {
+                    pmb_loc = mkloc loc;
+                    pmb_name = with_loc i loc;
+                    pmb_expr = module_expr me;
+                    pmb_attributes = [];
+                    pmb_implicit = Nonimplicit;
+                  } in
                   mkexp loc
-                    (Pexp_letmodule ((with_loc i loc), (module_expr me),
-                       (expr e)))
+                    (Pexp_letmodule (mb, (expr e)))
               | ExMat (loc, e, a) ->
                   mkexp loc (Pexp_match ((expr e), (match_case a [])))
               | ExNew (loc, id) -> mkexp loc (Pexp_new (long_type_ident id))
@@ -15582,7 +15598,7 @@ module Struct =
                     (Pexp_apply
                        ((mkexp loc
                            (Pexp_ident (array_function loc "String" "get"))),
-                       [ ("", (expr e1)); ("", (expr e2)) ]))
+                       [ (Papp_simple, (expr e1)); (Papp_simple, (expr e2)) ]))
               | ExStr (loc, s) ->
                   mkexp loc
                     (Pexp_constant
@@ -15611,7 +15627,7 @@ module Struct =
                   let e2 = ExSeq (loc, el)
                   in mkexp loc (Pexp_while ((expr e1), (expr e2)))
               | ExOpI (loc, i, ov, e) ->
-                  let fresh = override_flag loc ov
+                  let fresh = Open_all (override_flag loc ov)
                   in mkexp loc (Pexp_open (fresh, (long_uident i), (expr e)))
               | Ast.ExPkg (loc, (Ast.MeTyc (_, me, pt))) ->
                   mkexp loc
@@ -15648,10 +15664,10 @@ module Struct =
               | e -> expr e
             and label_expr =
               function
-              | ExLab (loc, lab, eo) -> (lab, (expr_of_lab loc lab eo))
+              | ExLab (loc, lab, eo) -> (papp lab, (expr_of_lab loc lab eo))
               | ExOlb (loc, lab, eo) ->
-                  (("?" ^ lab), (expr_of_lab loc lab eo))
-              | e -> ("", (expr e))
+                  (Papp_optional lab, (expr_of_lab loc lab eo))
+              | e -> (Papp_simple, (expr e))
             and binding x acc =
               match x with
               | Ast.BiAnd (_, x, y) -> binding x (binding y acc)
@@ -15719,7 +15735,7 @@ module Struct =
               in { pc_lhs = p; pc_guard = g; pc_rhs = expr e; }
             and mkfun loc lab def p e w =
               let () = match w with | Ast.ExNil _ -> () | _ -> assert false
-              in mkexp loc (Pexp_fun (lab, def, p, (expr e)))
+              in mkexp loc (Pexp_fun (parr lab, def, p, (expr e)))
             and mklabexp x acc =
               match x with
               | Ast.RbSem (_, x, y) -> mklabexp x (mklabexp y acc)
@@ -15847,6 +15863,7 @@ module Struct =
                           pmd_name = with_loc n loc;
                           pmd_type = module_type mt;
                           pmd_attributes = [];
+                          pmd_implicit = Nonimplicit;
                         })) ::
                     l
               | SgRecMod (loc, mb) ->
@@ -15868,12 +15885,12 @@ module Struct =
                           })) ::
                       l
               | SgOpn (loc, ov, id) ->
-                  let fresh = override_flag loc ov
+                  let fresh = Open_all (override_flag loc ov)
                   in
                     (mksig loc
                        (Psig_open
                           {
-                            popen_override = fresh;
+                            popen_flag = fresh;
                             popen_lid = long_uident id;
                             popen_attributes = [];
                             popen_loc = mkloc loc;
@@ -15896,6 +15913,7 @@ module Struct =
                     pmd_name = with_loc s loc;
                     pmd_type = module_type mt;
                     pmd_attributes = [];
+                    pmd_implicit = Nonimplicit;
                   } :: acc
               | _ -> assert false
             and module_str_binding x acc =
@@ -15915,6 +15933,7 @@ module Struct =
                         pmod_attributes = [];
                       };
                     pmb_attributes = [];
+                    pmb_implicit = Nonimplicit;
                   } :: acc
               | _ -> assert false
             and module_expr =
@@ -16037,6 +16056,7 @@ module Struct =
                           pmb_name = with_loc n loc;
                           pmb_expr = module_expr me;
                           pmb_attributes = [];
+                    pmb_implicit = Nonimplicit;
                         })) ::
                     l
               | StRecMod (loc, mb) ->
@@ -16058,12 +16078,12 @@ module Struct =
                           })) ::
                       l
               | StOpn (loc, ov, id) ->
-                  let fresh = override_flag loc ov
+                  let fresh = Open_all (override_flag loc ov)
                   in
                     (mkstr loc
                        (Pstr_open
                           {
-                            popen_override = fresh;
+                            popen_flag = fresh;
                             popen_lid = long_uident id;
                             popen_attributes = [];
                             popen_loc = mkloc loc;
@@ -16081,14 +16101,14 @@ module Struct =
                     (Pcty_constr ((long_class_ident id),
                        (List.map ctyp (list_of_opt_ctyp tl []))))
               | CtFun (loc, (TyLab (_, lab, t)), ct) ->
-                  mkcty loc (Pcty_arrow (lab, (ctyp t), (class_type ct)))
+                  mkcty loc (Pcty_arrow (parr lab, (ctyp t), (class_type ct)))
               | CtFun (loc, (TyOlb (loc1, lab, t)), ct) ->
                   let t = TyApp (loc1, (predef_option loc1), t)
                   in
                     mkcty loc
-                      (Pcty_arrow (("?" ^ lab), (ctyp t), (class_type ct)))
+                      (Pcty_arrow (Parr_optional lab, (ctyp t), (class_type ct)))
               | CtFun (loc, t, ct) ->
-                  mkcty loc (Pcty_arrow ("", (ctyp t), (class_type ct)))
+                  mkcty loc (Pcty_arrow (Parr_simple, (ctyp t), (class_type ct)))
               | CtSig (loc, t_o, ctfl) ->
                   let t =
                     (match t_o with | Ast.TyNil _ -> Ast.TyAny loc | t -> t) in
@@ -16187,22 +16207,22 @@ module Struct =
                        (List.map ctyp (list_of_opt_ctyp tl []))))
               | CeFun (loc, (PaLab (_, lab, po)), ce) ->
                   mkcl loc
-                    (Pcl_fun (lab, None, (patt_of_lab loc lab po),
+                    (Pcl_fun (parr lab, None, (patt_of_lab loc lab po),
                        (class_expr ce)))
               | CeFun (loc, (PaOlbi (_, lab, p, e)), ce) ->
                   let lab = paolab lab p
                   in
                     mkcl loc
-                      (Pcl_fun (("?" ^ lab), (Some (expr e)), (patt p),
+                      (Pcl_fun (Parr_optional lab, (Some (expr e)), (patt p),
                          (class_expr ce)))
               | CeFun (loc, (PaOlb (_, lab, p)), ce) ->
                   let lab = paolab lab p
                   in
                     mkcl loc
-                      (Pcl_fun (("?" ^ lab), None, (patt_of_lab loc lab p),
+                      (Pcl_fun (Parr_optional lab, None, (patt_of_lab loc lab p),
                          (class_expr ce)))
               | CeFun (loc, p, ce) ->
-                  mkcl loc (Pcl_fun ("", None, (patt p), (class_expr ce)))
+                  mkcl loc (Pcl_fun (Parr_simple, None, (patt p), (class_expr ce)))
               | CeLet (loc, rf, bi, ce) ->
                   mkcl loc
                     (Pcl_let ((mkrf rf), (binding bi []), (class_expr ce)))
@@ -16276,11 +16296,11 @@ module Struct =
                           (Cfk_virtual (ctyp t)))))) ::
                     l
               | CrAnt (_, _) -> assert false
-              
+
             let sig_item ast = sig_item ast []
-              
+
             let str_item ast = str_item ast []
-              
+
             let directive_arg =
               function
               | ExStr (_, s) -> Pdir_string s
@@ -16288,21 +16308,21 @@ module Struct =
               | Ast.ExId (_, (Ast.IdUid (_, "True"))) -> Pdir_bool true
               | Ast.ExId (_, (Ast.IdUid (_, "False"))) -> Pdir_bool false
               | e -> Pdir_ident (ident_noloc (ident_of_expr e))
-              
+
             let phrase =
               function
               | StDir (_, d, arg) -> Ptop_dir (d, (directive_arg arg))
               | si -> Ptop_def (str_item si)
-              
+
             let attribute loc s str =
               ((with_loc s loc), (PStr (str_item str)))
-              
+
             let () = attribute_fwd := attribute
-              
+
           end
-          
+
       end
-      
+
     module CleanAst =
       struct
         module Make (Ast : Sig.Camlp4Ast) =
@@ -16427,46 +16447,46 @@ module Struct =
                         Ast.CrSem (_, cst, (Ast.CrNil _)) -> cst
                     | cst -> cst
               end
-              
+
           end
-          
+
       end
-      
+
     module CommentFilter :
       sig
         module Make (Token : Sig.Camlp4Token) :
           sig
             open Token
-              
+
             type t
-            
+
             val mk : unit -> t
-              
+
             val define : Token.Filter.t -> t -> unit
-              
+
             val filter :
               t -> (Token.t * Loc.t) Stream.t -> (Token.t * Loc.t) Stream.t
-              
+
             val take_list : t -> (string * Loc.t) list
-              
+
             val take_stream : t -> (string * Loc.t) Stream.t
-              
+
           end
-          
+
       end =
       struct
         module Make (Token : Sig.Camlp4Token) =
           struct
             open Token
-              
+
             type t =
               (((string * Loc.t) Stream.t) * ((string * Loc.t) Queue.t))
-            
+
             let mk () =
               let q = Queue.create () in
               let f _ = try Some (Queue.take q) with | Queue.Empty -> None
               in ((Stream.from f), q)
-              
+
             let filter (_, q) =
               let rec self (__strm : _ Stream.t) =
                 match Stream.peek __strm with
@@ -16479,35 +16499,35 @@ module Struct =
                      in Stream.icons x (Stream.slazy (fun _ -> self xs)))
                 | _ -> Stream.sempty
               in self
-              
+
             let take_list (_, q) =
               let rec self accu =
                 if Queue.is_empty q
                 then accu
                 else self ((Queue.take q) :: accu)
               in self []
-              
+
             let take_stream = fst
-              
+
             let define token_fiter comments_strm =
               Token.Filter.define_filter token_fiter
                 (fun previous strm -> previous (filter comments_strm strm))
-              
+
           end
-          
+
       end
-      
+
     module DynLoader : sig include Sig.DynLoader
                               end =
       struct
         type t = string Queue.t
-        
+
         exception Error of string * string
-          
+
         let include_dir x y = Queue.add y x
-          
+
         let fold_load_path x f acc = Queue.fold (fun x y -> f y x) acc x
-          
+
         let mk ?(ocaml_stdlib = true) ?(camlp4_stdlib = true) () =
           let q = Queue.create ()
           in
@@ -16529,7 +16549,7 @@ module Struct =
              else ();
              include_dir q ".";
              q)
-          
+
         let find_in_path x name =
           if not (Filename.is_implicit name)
           then if Sys.file_exists name then name else raise Not_found
@@ -16547,7 +16567,7 @@ module Struct =
                     | x -> x)
                  None
              in match res with | None -> raise Not_found | Some x -> x)
-          
+
         let load =
           let _initialized = ref false
           in
@@ -16574,24 +16594,24 @@ module Struct =
                  with
                  | Dynlink.Error e ->
                      raise (Error (fname, (Dynlink.error_message e))))
-          
+
         let is_native = Dynlink.is_native
-          
+
       end
-      
+
     module EmptyError : sig include Sig.Error
                                end =
       struct
         type t = unit
-        
+
         exception E of t
-          
+
         let print _ = assert false
-          
+
         let to_string _ = assert false
-          
+
       end
-      
+
     module EmptyPrinter :
       sig module Make (Ast : Sig.Ast) : Sig.Printer(Ast).S
              end =
@@ -16600,32 +16620,32 @@ module Struct =
           struct
             let print_interf ?input_file:(_) ?output_file:(_) _ =
               failwith "No interface printer"
-              
+
             let print_implem ?input_file:(_) ?output_file:(_) _ =
               failwith "No implementation printer"
-              
+
           end
-          
+
       end
-      
+
     module FreeVars :
       sig
         module Make (Ast : Sig.Camlp4Ast) :
           sig
             module S : Set.S with type elt = string
-              
+
             val fold_binding_vars :
               (string -> 'accu -> 'accu) -> Ast.binding -> 'accu -> 'accu
-              
+
             class ['accu] c_fold_pattern_vars :
               (string -> 'accu -> 'accu) ->
                 'accu ->
                   object inherit Ast.fold val acc : 'accu method acc : 'accu
                   end
-              
+
             val fold_pattern_vars :
               (string -> 'accu -> 'accu) -> Ast.patt -> 'accu -> 'accu
-              
+
             class ['accu] fold_free_vars :
               (string -> 'accu -> 'accu) ->
                 ?env_init: S.t ->
@@ -16640,17 +16660,17 @@ module Struct =
                       method add_patt : Ast.patt -> 'self_type
                       method add_binding : Ast.binding -> 'self_type
                     end
-              
+
             val free_vars : S.t -> Ast.expr -> S.t
-              
+
           end
-          
+
       end =
       struct
         module Make (Ast : Sig.Camlp4Ast) =
           struct
             module S = Set.Make(String)
-              
+
             class ['accu] c_fold_pattern_vars f init =
               object inherit Ast.fold as super
                 val acc = init
@@ -16662,10 +16682,10 @@ module Struct =
                       Ast.PaOlb (_, s, (Ast.PaNil _)) -> {< acc = f s acc; >}
                   | p -> super#patt p
               end
-              
+
             let fold_pattern_vars f p init =
               ((new c_fold_pattern_vars f init)#patt p)#acc
-              
+
             let rec fold_binding_vars f bi acc =
               match bi with
               | Ast.BiAnd (_, bi1, bi2) ->
@@ -16673,7 +16693,7 @@ module Struct =
               | Ast.BiEq (_, p, _) -> fold_pattern_vars f p acc
               | Ast.BiNil _ -> acc
               | Ast.BiAnt (_, _) -> assert false
-              
+
             class ['accu] fold_free_vars (f : string -> 'accu -> 'accu)
                     ?(env_init = S.empty) free_init =
               object (o)
@@ -16742,32 +16762,32 @@ module Struct =
                   | Ast.MeStr (_, st) -> (o#str_item st)#set_env env
                   | me -> super#module_expr me
               end
-              
+
             let free_vars env_init e =
               let fold = new fold_free_vars S.add ~env_init S.empty
               in (fold#expr e)#free
-              
+
           end
-          
+
       end
-      
+
     module Grammar =
       struct
         module Structure =
           struct
             open Sig.Grammar
-              
+
             module type S =
               sig
                 module Loc : Sig.Loc
-                  
+
                 module Token : Sig.Token with module Loc = Loc
-                  
+
                 module Lexer : Sig.Lexer with module Loc = Loc
                   and module Token = Token
-                  
+
                 module Action : Sig.Grammar.Action
-                  
+
                 type gram =
                   { gfilter : Token.Filter.t;
                     gkeywords : (string, int ref) Hashtbl.t;
@@ -16775,17 +16795,17 @@ module Struct =
                       Loc.t -> char Stream.t -> (Token.t * Loc.t) Stream.t;
                     warning_verbose : bool ref; error_verbose : bool ref
                   }
-                
+
                 type token_info =
                   { prev_loc : Loc.t; cur_loc : Loc.t; prev_loc_only : bool
                   }
-                
+
                 type token_stream = (Token.t * token_info) Stream.t
-                
+
                 type efun = token_stream -> Action.t
-                
+
                 type token_pattern = ((Token.t -> bool) * string)
-                
+
                 type internal_entry =
                   { egram : gram; ename : string;
                     mutable estart : int -> efun;
@@ -16821,57 +16841,57 @@ module Struct =
                   and node =
                   { node : symbol; son : tree; brother : tree
                   }
-                
+
                 type production_rule = ((symbol list) * Action.t)
-                
+
                 type single_extend_statment =
                   ((string option) * (assoc option) * (production_rule list))
-                
+
                 type extend_statment =
                   ((position option) * (single_extend_statment list))
-                
+
                 type delete_statment = symbol list
-                
+
                 type ('a, 'b, 'c) fold =
                   internal_entry ->
                     symbol list -> ('a Stream.t -> 'b) -> 'a Stream.t -> 'c
-                
+
                 type ('a, 'b, 'c) foldsep =
                   internal_entry ->
                     symbol list ->
                       ('a Stream.t -> 'b) ->
                         ('a Stream.t -> unit) -> 'a Stream.t -> 'c
-                
+
                 val get_filter : gram -> Token.Filter.t
-                  
+
                 val using : gram -> string -> unit
-                  
+
                 val removing : gram -> string -> unit
-                  
+
               end
-              
+
             module Make (Lexer : Sig.Lexer) =
               struct
                 module Loc = Lexer.Loc
-                  
+
                 module Token = Lexer.Token
-                  
+
                 module Action : Sig.Grammar.Action =
                   struct
                     type t = Obj.t
-                    
+
                     let mk = Obj.repr
-                      
+
                     let get = Obj.obj
-                      
+
                     let getf = Obj.obj
-                      
+
                     let getf2 = Obj.obj
-                      
+
                   end
-                  
+
                 module Lexer = Lexer
-                  
+
                 type gram =
                   { gfilter : Token.Filter.t;
                     gkeywords : (string, int ref) Hashtbl.t;
@@ -16879,17 +16899,17 @@ module Struct =
                       Loc.t -> char Stream.t -> (Token.t * Loc.t) Stream.t;
                     warning_verbose : bool ref; error_verbose : bool ref
                   }
-                
+
                 type token_info =
                   { prev_loc : Loc.t; cur_loc : Loc.t; prev_loc_only : bool
                   }
-                
+
                 type token_stream = (Token.t * token_info) Stream.t
-                
+
                 type efun = token_stream -> Action.t
-                
+
                 type token_pattern = ((Token.t -> bool) * string)
-                
+
                 type internal_entry =
                   { egram : gram; ename : string;
                     mutable estart : int -> efun;
@@ -16925,33 +16945,33 @@ module Struct =
                   and node =
                   { node : symbol; son : tree; brother : tree
                   }
-                
+
                 type production_rule = ((symbol list) * Action.t)
-                
+
                 type single_extend_statment =
                   ((string option) * (assoc option) * (production_rule list))
-                
+
                 type extend_statment =
                   ((position option) * (single_extend_statment list))
-                
+
                 type delete_statment = symbol list
-                
+
                 type ('a, 'b, 'c) fold =
                   internal_entry ->
                     symbol list -> ('a Stream.t -> 'b) -> 'a Stream.t -> 'c
-                
+
                 type ('a, 'b, 'c) foldsep =
                   internal_entry ->
                     symbol list ->
                       ('a Stream.t -> 'b) ->
                         ('a Stream.t -> unit) -> 'a Stream.t -> 'c
-                
+
                 let get_filter g = g.gfilter
-                  
+
                 let token_location r = r.cur_loc
-                  
+
                 type 'a not_filtered = 'a
-                
+
                 let using { gkeywords = table; gfilter = filter } kwd =
                   let r =
                     try Hashtbl.find table kwd
@@ -16959,7 +16979,7 @@ module Struct =
                     | Not_found ->
                         let r = ref 0 in (Hashtbl.add table kwd r; r)
                   in (Token.Filter.keyword_added filter kwd (!r = 0); incr r)
-                  
+
                 let removing { gkeywords = table; gfilter = filter } kwd =
                   let r = Hashtbl.find table kwd in
                   let () = decr r
@@ -16969,17 +16989,17 @@ module Struct =
                       (Token.Filter.keyword_removed filter kwd;
                        Hashtbl.remove table kwd)
                     else ()
-                  
+
               end
-              
+
           end
-          
+
         module Search =
           struct
             module Make (Structure : Structure.S) =
               struct
                 open Structure
-                  
+
                 let tree_in_entry prev_symb tree =
                   function
                   | Dlevels levels ->
@@ -17068,22 +17088,22 @@ module Struct =
                          | _ -> None)
                       in search_levels levels
                   | Dparser _ -> tree
-                  
+
               end
-              
+
           end
-          
+
         module Tools =
           struct
             let get_prev_loc_only = ref false
-              
+
             module Make (Structure : Structure.S) =
               struct
                 open Structure
-                  
+
                 let empty_entry ename _ =
                   raise (Stream.Error ("entry [" ^ (ename ^ "] is empty")))
-                  
+
                 let rec stream_map f (__strm : _ Stream.t) =
                   match Stream.peek __strm with
                   | Some x ->
@@ -17093,7 +17113,7 @@ module Struct =
                          Stream.lcons (fun _ -> f x)
                            (Stream.slazy (fun _ -> stream_map f strm)))
                   | _ -> Stream.sempty
-                  
+
                 let keep_prev_loc strm =
                   match Stream.peek strm with
                   | None -> Stream.sempty
@@ -17130,15 +17150,15 @@ module Struct =
                                          (fun _ -> go cur_loc strm)))
                              | _ -> Stream.sempty)
                       in go init_loc strm
-                  
+
                 let drop_prev_loc strm =
                   stream_map (fun (tok, r) -> (tok, (r.cur_loc))) strm
-                  
+
                 let get_cur_loc strm =
                   match Stream.peek strm with
                   | Some ((_, r)) -> r.cur_loc
                   | None -> Loc.ghost
-                  
+
                 let get_prev_loc strm =
                   (get_prev_loc_only := true;
                    let result =
@@ -17151,12 +17171,12 @@ module Struct =
                          -> prev_loc
                      | None -> Loc.ghost
                    in (get_prev_loc_only := false; result))
-                  
+
                 let is_level_labelled n lev =
                   match lev.lname with | Some n1 -> n = n1 | None -> false
-                  
+
                 let warning_verbose = ref true
-                  
+
                 let rec get_token_list entry tokl last_tok tree =
                   match tree with
                   | Node
@@ -17171,14 +17191,14 @@ module Struct =
                       else
                         Some
                           (((List.rev (last_tok :: tokl)), last_tok, tree))
-                  
+
                 let is_antiquot s =
                   let len = String.length s in (len > 1) && (s.[0] = '$')
-                  
+
                 let eq_Stoken_ids s1 s2 =
                   (not (is_antiquot s1)) &&
                     ((not (is_antiquot s2)) && (s1 = s2))
-                  
+
                 let logically_eq_symbols entry =
                   let rec eq_symbols s1 s2 =
                     match (s1, s2) with
@@ -17207,7 +17227,7 @@ module Struct =
                         -> true
                     | _ -> false
                   in eq_symbols
-                  
+
                 let rec eq_symbol s1 s2 =
                   match (s1, s2) with
                   | (Snterm e1, Snterm e2) -> e1 == e2
@@ -17223,78 +17243,78 @@ module Struct =
                   | (Stoken ((_, s1)), Stoken ((_, s2))) ->
                       eq_Stoken_ids s1 s2
                   | _ -> s1 = s2
-                  
+
               end
-              
+
           end
-          
+
         module Print :
           sig
             module Make (Structure : Structure.S) :
               sig
                 val flatten_tree :
                   Structure.tree -> (Structure.symbol list) list
-                  
+
                 val print_symbol :
                   Format.formatter -> Structure.symbol -> unit
-                  
+
                 val print_meta :
                   Format.formatter -> string -> Structure.symbol list -> unit
-                  
+
                 val print_symbol1 :
                   Format.formatter -> Structure.symbol -> unit
-                  
+
                 val print_rule :
                   Format.formatter -> Structure.symbol list -> unit
-                  
+
                 val print_level :
                   Format.formatter ->
                     (Format.formatter -> unit -> unit) ->
                       (Structure.symbol list) list -> unit
-                  
+
                 val levels : Format.formatter -> Structure.level list -> unit
-                  
+
                 val entry :
                   Format.formatter -> Structure.internal_entry -> unit
-                  
+
               end
-              
+
             module MakeDump (Structure : Structure.S) :
               sig
                 val print_symbol :
                   Format.formatter -> Structure.symbol -> unit
-                  
+
                 val print_meta :
                   Format.formatter -> string -> Structure.symbol list -> unit
-                  
+
                 val print_symbol1 :
                   Format.formatter -> Structure.symbol -> unit
-                  
+
                 val print_rule :
                   Format.formatter -> Structure.symbol list -> unit
-                  
+
                 val print_level :
                   Format.formatter ->
                     (Format.formatter -> unit -> unit) ->
                       (Structure.symbol list) list -> unit
-                  
+
                 val levels : Format.formatter -> Structure.level list -> unit
-                  
+
                 val entry :
                   Format.formatter -> Structure.internal_entry -> unit
-                  
+
               end
-              
+
           end =
           struct
             module Make (Structure : Structure.S) =
               struct
                 open Structure
-                  
+
                 open Format
-                  
+
                 open Sig.Grammar
-                  
+
                 let rec flatten_tree =
                   function
                   | DeadEnd -> []
@@ -17302,7 +17322,7 @@ module Struct =
                   | Node { node = n; brother = b; son = s } ->
                       (List.map (fun l -> n :: l) (flatten_tree s)) @
                         (flatten_tree b)
-                  
+
                 let rec print_symbol ppf =
                   function
                   | Smeta (n, sl, _) -> print_meta ppf n sl
@@ -17368,7 +17388,7 @@ module Struct =
                            fun ppf -> fprintf ppf "%a| " pp_print_space ()))
                        (fun _ -> ()) rules
                    in fprintf ppf " ]@]")
-                  
+
                 let levels ppf elev =
                   let _ =
                     List.fold_left
@@ -17391,26 +17411,26 @@ module Struct =
                             fun ppf -> fprintf ppf "@,| "))
                       (fun _ -> ()) elev
                   in ()
-                  
+
                 let entry ppf e =
                   (fprintf ppf "@[<v 0>%s: [ " e.ename;
                    (match e.edesc with
                     | Dlevels elev -> levels ppf elev
                     | Dparser _ -> fprintf ppf "<parser>");
                    fprintf ppf " ]@]")
-                  
+
               end
-              
+
             module MakeDump (Structure : Structure.S) =
               struct
                 open Structure
-                  
+
                 open Format
-                  
+
                 open Sig.Grammar
-                  
+
                 type brothers = | Bro of symbol * brothers list
-                
+
                 let rec print_tree ppf tree =
                   let rec get_brothers acc =
                     function
@@ -17510,7 +17530,7 @@ module Struct =
                            fun ppf -> fprintf ppf "%a| " pp_print_space ()))
                        (fun _ -> ()) rules
                    in fprintf ppf " ]@]")
-                  
+
                 let levels ppf elev =
                   let _ =
                     List.fold_left
@@ -17532,32 +17552,32 @@ module Struct =
                           fun ppf -> fprintf ppf "@,| "))
                       (fun _ -> ()) elev
                   in ()
-                  
+
                 let entry ppf e =
                   (fprintf ppf "@[<v 0>%s: [ " e.ename;
                    (match e.edesc with
                     | Dlevels elev -> levels ppf elev
                     | Dparser _ -> fprintf ppf "<parser>");
                    fprintf ppf " ]@]")
-                  
+
               end
-              
+
           end
-          
+
         module Failed =
           struct
             module Make (Structure : Structure.S) =
               struct
                 module Tools = Tools.Make(Structure)
-                  
+
                 module Search = Search.Make(Structure)
-                  
+
                 module Print = Print.Make(Structure)
-                  
+
                 open Structure
-                  
+
                 open Format
-                  
+
                 let rec name_of_symbol entry =
                   function
                   | Snterm e -> "[" ^ (e.ename ^ "]")
@@ -17567,7 +17587,7 @@ module Struct =
                   | Stoken ((_, descr)) -> descr
                   | Skeyword kwd -> "\"" ^ (kwd ^ "\"")
                   | _ -> "???"
-                  
+
                 let rec name_of_symbol_failed entry =
                   function
                   | Slist0 s | Slist0sep (s, _) | Slist1 s | Slist1sep (s, _)
@@ -17611,9 +17631,9 @@ module Struct =
                                      | _ -> assert false))
                                "" tokl)
                   | DeadEnd | LocAct (_, _) -> "???"
-                  
+
                 let magic _s x = Obj.magic x
-                  
+
                 let tree_failed entry prev_symb_result prev_symb tree =
                   let txt = name_of_tree_failed entry tree in
                   let txt =
@@ -17669,42 +17689,42 @@ module Struct =
                            fprintf ppf "@]@."))
                      else ();
                      txt ^ (" (in [" ^ (entry.ename ^ "])")))
-                  
+
                 let symb_failed entry prev_symb_result prev_symb symb =
                   let tree =
                     Node { node = symb; brother = DeadEnd; son = DeadEnd; }
                   in tree_failed entry prev_symb_result prev_symb tree
-                  
+
                 let symb_failed_txt e s1 s2 = symb_failed e 0 s1 s2
-                  
+
               end
-              
+
           end
-          
+
         module Parser =
           struct
             module Make (Structure : Structure.S) =
               struct
                 module Tools = Tools.Make(Structure)
-                  
+
                 module Failed = Failed.Make(Structure)
-                  
+
                 module Print = Print.Make(Structure)
-                  
+
                 open Structure
-                  
+
                 open Sig.Grammar
-                  
+
                 module StreamOrig = Stream
-                  
+
                 let njunk strm n = for i = 1 to n do Stream.junk strm done
-                  
+
                 let loc_bp = Tools.get_cur_loc
-                  
+
                 let loc_ep = Tools.get_prev_loc
-                  
+
                 let drop_prev_loc = Tools.drop_prev_loc
-                  
+
                 let add_loc bp parse_fun strm =
                   let x = parse_fun strm in
                   let ep = loc_ep strm in
@@ -17713,26 +17733,26 @@ module Struct =
                     then Loc.join bp
                     else Loc.merge bp ep
                   in (x, loc)
-                  
+
                 let stream_peek_nth strm n =
                   let rec loop i =
                     function
                     | x :: xs -> if i = 1 then Some x else loop (i - 1) xs
                     | [] -> None
                   in loop n (Stream.npeek n strm)
-                  
+
                 module Stream =
                   struct
                     type 'a t = 'a StreamOrig.t
-                    
+
                     exception Failure = StreamOrig.Failure
-                      
+
                     exception Error = StreamOrig.Error
-                      
+
                     let peek = StreamOrig.peek
-                      
+
                     let junk = StreamOrig.junk
-                      
+
                     let dup strm =
                       let peek_nth n =
                         let rec loop n =
@@ -17742,9 +17762,9 @@ module Struct =
                           | _ :: l -> loop (n - 1) l
                         in loop n (Stream.npeek (n + 1) strm)
                       in Stream.from peek_nth
-                      
+
                   end
-                  
+
                 let try_parser ps strm =
                   let strm' = Stream.dup strm in
                   let r =
@@ -17754,7 +17774,7 @@ module Struct =
                         -> raise Stream.Failure
                     | exc -> raise exc
                   in (njunk strm (StreamOrig.count strm'); r)
-                  
+
                 let level_number entry lab =
                   let rec lookup levn =
                     function
@@ -17767,18 +17787,18 @@ module Struct =
                     match entry.edesc with
                     | Dlevels elev -> lookup 0 elev
                     | Dparser _ -> raise Not_found
-                  
+
                 let strict_parsing = ref false
-                  
+
                 let strict_parsing_warning = ref false
-                  
+
                 let rec top_symb entry =
                   function
                   | Sself | Snext -> Snterm entry
                   | Snterml (e, _) -> Snterm e
                   | Slist1sep (s, sep) -> Slist1sep ((top_symb entry s), sep)
                   | _ -> raise Stream.Failure
-                  
+
                 let top_tree entry =
                   function
                   | Node { node = s; brother = bro; son = son } ->
@@ -17786,14 +17806,14 @@ module Struct =
                         { node = top_symb entry s; brother = bro; son = son;
                         }
                   | LocAct (_, _) | DeadEnd -> raise Stream.Failure
-                  
+
                 let entry_of_symb entry =
                   function
                   | Sself | Snext -> entry
                   | Snterm e -> e
                   | Snterml (e, _) -> e
                   | _ -> raise Stream.Failure
-                  
+
                 let continue entry loc a s son p1 (__strm : _ Stream.t) =
                   let a = (entry_of_symb entry s).econtinue 0 loc a __strm in
                   let act =
@@ -17803,12 +17823,12 @@ module Struct =
                         raise
                           (Stream.Error (Failed.tree_failed entry a s son))
                   in Action.mk (fun _ -> Action.getf act a)
-                  
+
                 let skip_if_empty bp strm =
                   if (loc_bp strm) = bp
                   then Action.mk (fun _ -> raise Stream.Failure)
                   else raise Stream.Failure
-                  
+
                 let do_recover parser_of_tree entry nlevn alevn loc a s son
                                (__strm : _ Stream.t) =
                   try
@@ -17821,7 +17841,7 @@ module Struct =
                        | Stream.Failure ->
                            continue entry loc a s son
                              (parser_of_tree entry nlevn alevn son) __strm)
-                  
+
                 let recover parser_of_tree entry nlevn alevn loc a s son strm
                             =
                   if !strict_parsing
@@ -17843,7 +17863,7 @@ module Struct =
                      in
                        do_recover parser_of_tree entry nlevn alevn loc a s
                          son strm)
-                  
+
                 let rec parser_of_tree entry nlevn alevn =
                   function
                   | DeadEnd ->
@@ -18144,7 +18164,7 @@ module Struct =
                          | _ -> raise Stream.Failure)
                 and parse_top_symb entry symb strm =
                   parser_of_symbol entry 0 (top_symb entry symb) strm
-                  
+
                 let rec start_parser_of_levels entry clevn =
                   function
                   | [] ->
@@ -18192,13 +18212,13 @@ module Struct =
                                                   entry.econtinue levn loc a
                                                     strm
                                             | _ -> p1 levn __strm))))
-                  
+
                 let start_parser_of_entry entry =
                   match entry.edesc with
                   | Dlevels [] -> Tools.empty_entry entry.ename
                   | Dlevels elev -> start_parser_of_levels entry 0 elev
                   | Dparser p -> (fun _ -> p)
-                  
+
                 let rec continue_parser_of_levels entry clevn =
                   function
                   | [] ->
@@ -18231,7 +18251,7 @@ module Struct =
                                              add_loc bp p2 __strm in
                                            let a = Action.getf2 act a loc
                                            in entry.econtinue levn loc a strm)))
-                  
+
                 let continue_parser_of_entry entry =
                   match entry.edesc with
                   | Dlevels elev ->
@@ -18242,32 +18262,32 @@ module Struct =
                   | Dparser _ ->
                       (fun _ _ _ (__strm : _ Stream.t) ->
                          raise Stream.Failure)
-                  
+
               end
-              
+
           end
-          
+
         module Insert =
           struct
             module Make (Structure : Structure.S) =
               struct
                 module Tools = Tools.Make(Structure)
-                  
+
                 module Parser = Parser.Make(Structure)
-                  
+
                 open Structure
-                  
+
                 open Format
-                  
+
                 open Sig.Grammar
-                  
+
                 let is_before s1 s2 =
                   match (s1, s2) with
                   | ((Skeyword _ | Stoken _), (Skeyword _ | Stoken _)) ->
                       false
                   | ((Skeyword _ | Stoken _), _) -> true
                   | _ -> false
-                  
+
                 let rec derive_eps =
                   function
                   | Slist0 _ | Slist0sep (_, _) | Sopt _ -> true
@@ -18284,7 +18304,7 @@ module Struct =
                       ((derive_eps s) && (tree_derive_eps son)) ||
                         (tree_derive_eps bro)
                   | DeadEnd -> false
-                  
+
                 let empty_lev lname assoc =
                   let assoc = match assoc with | Some a -> a | None -> LeftA
                   in
@@ -18294,7 +18314,7 @@ module Struct =
                       lsuffix = DeadEnd;
                       lprefix = DeadEnd;
                     }
-                  
+
                 let change_lev entry lev n lname assoc =
                   let a =
                     match assoc with
@@ -18326,10 +18346,10 @@ module Struct =
                        lsuffix = lev.lsuffix;
                        lprefix = lev.lprefix;
                      })
-                  
+
                 let change_to_self entry =
                   function | Snterm e when e == entry -> Sself | x -> x
-                  
+
                 let get_level entry position levs =
                   match position with
                   | Some First -> ([], empty_lev, levs)
@@ -18387,7 +18407,7 @@ module Struct =
                        | lev :: levs ->
                            ([], (change_lev entry lev "<top>"), levs)
                        | [] -> ([], empty_lev, []))
-                  
+
                 let rec check_gram entry =
                   function
                   | Snterm e ->
@@ -18426,12 +18446,12 @@ module Struct =
                        tree_check_gram entry bro;
                        tree_check_gram entry son)
                   | LocAct (_, _) | DeadEnd -> ()
-                  
+
                 let get_initial =
                   function
                   | Sself :: symbols -> (true, symbols)
                   | symbols -> (false, symbols)
-                  
+
                 let insert_tokens gram symbols =
                   let rec insert =
                     function
@@ -18449,7 +18469,7 @@ module Struct =
                         (insert s; tinsert bro; tinsert son)
                     | LocAct (_, _) | DeadEnd -> ()
                   in List.iter insert symbols
-                  
+
                 let insert_tree entry gsymbols action tree =
                   let rec insert symbols tree =
                     match symbols with
@@ -18524,7 +18544,7 @@ module Struct =
                              | None -> None)
                     | LocAct (_, _) | DeadEnd -> None
                   in insert gsymbols tree
-                  
+
                 let insert_level entry e1 symbols action slev =
                   match e1 with
                   | true ->
@@ -18543,7 +18563,7 @@ module Struct =
                         lprefix =
                           insert_tree entry symbols action slev.lprefix;
                       }
-                  
+
                 let levels_of_rules entry position rules =
                   let elev =
                     match entry.edesc with
@@ -18581,7 +18601,7 @@ module Struct =
                               in ((lev :: levs), empty_lev))
                            ([], make_lev) rules
                        in levs1 @ ((List.rev levs) @ levs2))
-                  
+
                 let extend entry (position, rules) =
                   let elev = levels_of_rules entry position rules
                   in
@@ -18594,15 +18614,15 @@ module Struct =
                        fun lev bp a strm ->
                          let f = Parser.continue_parser_of_entry entry
                          in (entry.econtinue <- f; f lev bp a strm))
-                  
+
               end
-              
+
           end
-          
+
         module Delete =
           struct
             exception Rule_not_found of (string * string)
-              
+
             let _ =
               let () =
                 Printexc.register_printer
@@ -18615,17 +18635,17 @@ module Struct =
                        in Some msg
                    | _ -> None)
               in ()
-              
+
             module Make (Structure : Structure.S) =
               struct
                 module Tools = Tools.Make(Structure)
-                  
+
                 module Parser = Parser.Make(Structure)
-                  
+
                 module Print = Print.Make(Structure)
-                  
+
                 open Structure
-                  
+
                 let raise_rule_not_found entry symbols =
                   let to_string f x =
                     let buff = Buffer.create 128 in
@@ -18637,7 +18657,7 @@ module Struct =
                   let entry = to_string Print.entry entry in
                   let symbols = to_string Print.print_rule symbols
                   in raise (Rule_not_found ((symbols, entry)))
-                  
+
                 let delete_rule_in_tree entry =
                   let rec delete_in_tree symbols tree =
                     match (symbols, tree) with
@@ -18689,7 +18709,7 @@ module Struct =
                         in Some ((None, t))
                     | None -> None
                   in delete_in_tree
-                  
+
                 let rec decr_keyw_use gram =
                   function
                   | Skeyword kwd -> removing gram kwd
@@ -18710,7 +18730,7 @@ module Struct =
                       (decr_keyw_use gram n.node;
                        decr_keyw_use_in_tree gram n.son;
                        decr_keyw_use_in_tree gram n.brother)
-                  
+
                 let rec delete_rule_in_suffix entry symbols =
                   function
                   | lev :: levs ->
@@ -18737,7 +18757,7 @@ module Struct =
                              delete_rule_in_suffix entry symbols levs
                            in lev :: levs)
                   | [] -> raise_rule_not_found entry symbols
-                  
+
                 let rec delete_rule_in_prefix entry symbols =
                   function
                   | lev :: levs ->
@@ -18764,7 +18784,7 @@ module Struct =
                              delete_rule_in_prefix entry symbols levs
                            in lev :: levs)
                   | [] -> raise_rule_not_found entry symbols
-                  
+
                 let rec delete_rule_in_level_list entry symbols levs =
                   match symbols with
                   | Sself :: symbols ->
@@ -18772,7 +18792,7 @@ module Struct =
                   | Snterm e :: symbols when e == entry ->
                       delete_rule_in_suffix entry symbols levs
                   | _ -> delete_rule_in_prefix entry symbols levs
-                  
+
                 let delete_rule entry sl =
                   match entry.edesc with
                   | Dlevels levs ->
@@ -18788,49 +18808,49 @@ module Struct =
                               let f = Parser.continue_parser_of_entry entry
                               in (entry.econtinue <- f; f lev bp a strm)))
                   | Dparser _ -> ()
-                  
+
               end
-              
+
           end
-          
+
         module Fold :
           sig
             module Make (Structure : Structure.S) :
               sig
                 open Structure
-                  
+
                 val sfold0 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-                  
+
                 val sfold1 : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) fold
-                  
+
                 val sfold0sep : ('a -> 'b -> 'b) -> 'b -> (_, 'a, 'b) foldsep
-                  
+
               end
-              
+
           end =
           struct
             module Make (Structure : Structure.S) =
               struct
                 open Structure
-                  
+
                 open Format
-                  
+
                 module Parse = Parser.Make(Structure)
-                  
+
                 module Fail = Failed.Make(Structure)
-                  
+
                 open Sig.Grammar
-                  
+
                 module Stream =
                   struct
                     type 'a t = 'a Stream.t
-                    
+
                     exception Failure = Stream.Failure
-                      
+
                     exception Error = Stream.Error
-                      
+
                   end
-                  
+
                 let sfold0 f e _entry _symbl psymb =
                   let rec fold accu (__strm : _ Stream.t) =
                     match try Some (psymb __strm)
@@ -18839,7 +18859,7 @@ module Struct =
                     | Some a -> fold (f a accu) __strm
                     | _ -> accu
                   in fun (__strm : _ Stream.t) -> fold e __strm
-                  
+
                 let sfold1 f e _entry _symbl psymb =
                   let rec fold accu (__strm : _ Stream.t) =
                     match try Some (psymb __strm)
@@ -18853,7 +18873,7 @@ module Struct =
                       in
                         try fold (f a e) __strm
                         with | Stream.Failure -> raise (Stream.Error "")
-                  
+
                 let sfold0sep f e entry symbl psymb psep =
                   let failed =
                     function
@@ -18878,7 +18898,7 @@ module Struct =
                       with
                       | Some a -> kont (f a e) __strm
                       | _ -> e
-                  
+
                 let sfold1sep f e entry symbl psymb psep =
                   let failed =
                     function
@@ -18910,35 +18930,35 @@ module Struct =
                   in
                     fun (__strm : _ Stream.t) ->
                       let a = psymb __strm in kont (f a e) __strm
-                  
+
               end
-              
+
           end
-          
+
         module Entry =
           struct
             module Make (Structure : Structure.S) =
               struct
                 module Dump = Print.MakeDump(Structure)
-                  
+
                 module Print = Print.Make(Structure)
-                  
+
                 module Tools = Tools.Make(Structure)
-                  
+
                 open Format
-                  
+
                 open Structure
-                  
+
                 open Tools
-                  
+
                 type 'a t = internal_entry
-                
+
                 let name e = e.ename
-                  
+
                 let print ppf e = fprintf ppf "%a@\n" Print.entry e
-                  
+
                 let dump ppf e = fprintf ppf "%a@\n" Dump.entry e
-                  
+
                 let mk g n =
                   {
                     egram = g;
@@ -18949,7 +18969,7 @@ module Struct =
                          raise Stream.Failure);
                     edesc = Dlevels [];
                   }
-                  
+
                 let action_parse entry ts : Action.t =
                   try entry.estart 0 ts
                   with
@@ -18958,28 +18978,28 @@ module Struct =
                         (Stream.Error ("illegal begin of " ^ entry.ename))
                   | (Loc.Exc_located (_, _) as exc) -> raise exc
                   | exc -> Loc.raise (get_prev_loc ts) exc
-                  
+
                 let lex entry loc cs = entry.egram.glexer loc cs
-                  
+
                 let lex_string entry loc str =
                   lex entry loc (Stream.of_string str)
-                  
+
                 let filter entry ts =
                   keep_prev_loc
                     (Token.Filter.filter (get_filter entry.egram) ts)
-                  
+
                 let parse_tokens_after_filter entry ts =
                   Action.get (action_parse entry ts)
-                  
+
                 let parse_tokens_before_filter entry ts =
                   parse_tokens_after_filter entry (filter entry ts)
-                  
+
                 let parse entry loc cs =
                   parse_tokens_before_filter entry (lex entry loc cs)
-                  
+
                 let parse_string entry loc str =
                   parse_tokens_before_filter entry (lex_string entry loc str)
-                  
+
                 let of_parser g n
                   (p : (Token.t * token_info) Stream.t -> 'a) : 'a t =
                   let f ts = Action.mk (p ts)
@@ -18993,7 +19013,7 @@ module Struct =
                            raise Stream.Failure);
                       edesc = Dparser f;
                     }
-                  
+
                 let setup_parser e
                                  (p : (Token.t * token_info) Stream.t -> 'a)
                                  =
@@ -19004,42 +19024,42 @@ module Struct =
                        (fun _ _ _ (__strm : _ Stream.t) ->
                           raise Stream.Failure);
                      e.edesc <- Dparser f)
-                  
+
                 let clear e =
                   (e.estart <-
                      (fun _ (__strm : _ Stream.t) -> raise Stream.Failure);
                    e.econtinue <-
                      (fun _ _ _ (__strm : _ Stream.t) -> raise Stream.Failure);
                    e.edesc <- Dlevels [])
-                  
+
                 let obj x = x
-                  
+
               end
-              
+
           end
-          
+
         module Static =
           struct
             let uncurry f (x, y) = f x y
-              
+
             let flip f x y = f y x
-              
+
             module Make (Lexer : Sig.Lexer) :
               Sig.Grammar.Static with module Loc = Lexer.Loc
               and module Token = Lexer.Token =
               struct
                 module Structure = Structure.Make(Lexer)
-                  
+
                 module Delete = Delete.Make(Structure)
-                  
+
                 module Insert = Insert.Make(Structure)
-                  
+
                 module Fold = Fold.Make(Structure)
-                  
+
                 module Tools = Tools.Make(Structure)
-                  
+
                 include Structure
-                  
+
                 let gram =
                   let gkeywords = Hashtbl.create 301
                   in
@@ -19050,71 +19070,71 @@ module Struct =
                       warning_verbose = ref true;
                       error_verbose = Camlp4_config.verbose;
                     }
-                  
+
                 module Entry =
                   struct
                     module E = Entry.Make(Structure)
-                      
+
                     type 'a t = 'a E.t
-                    
+
                     let mk = E.mk gram
-                      
+
                     let of_parser name strm = E.of_parser gram name strm
-                      
+
                     let setup_parser = E.setup_parser
-                      
+
                     let name = E.name
-                      
+
                     let print = E.print
-                      
+
                     let clear = E.clear
-                      
+
                     let dump = E.dump
-                      
+
                     let obj x = x
-                      
+
                   end
-                  
+
                 let get_filter () = gram.gfilter
-                  
+
                 let lex loc cs = gram.glexer loc cs
-                  
+
                 let lex_string loc str = lex loc (Stream.of_string str)
-                  
+
                 let filter ts =
                   Tools.keep_prev_loc (Token.Filter.filter gram.gfilter ts)
-                  
+
                 let parse_tokens_after_filter entry ts =
                   Entry.E.parse_tokens_after_filter entry ts
-                  
+
                 let parse_tokens_before_filter entry ts =
                   parse_tokens_after_filter entry (filter ts)
-                  
+
                 let parse entry loc cs =
                   parse_tokens_before_filter entry (lex loc cs)
-                  
+
                 let parse_string entry loc str =
                   parse_tokens_before_filter entry (lex_string loc str)
-                  
+
                 let delete_rule = Delete.delete_rule
-                  
+
                 let srules e rl =
                   Stree
                     (List.fold_left (flip (uncurry (Insert.insert_tree e)))
                        DeadEnd rl)
-                  
+
                 let sfold0 = Fold.sfold0
-                  
+
                 let sfold1 = Fold.sfold1
-                  
+
                 let sfold0sep = Fold.sfold0sep
-                  
+
                 let extend = Insert.extend
-                  
+
               end
-              
+
           end
-          
+
         module Dynamic =
           struct
             module Make (Lexer : Sig.Lexer) :
@@ -19122,19 +19142,19 @@ module Struct =
               and module Token = Lexer.Token =
               struct
                 module Structure = Structure.Make(Lexer)
-                  
+
                 module Delete = Delete.Make(Structure)
-                  
+
                 module Insert = Insert.Make(Structure)
-                  
+
                 module Entry = Entry.Make(Structure)
-                  
+
                 module Fold = Fold.Make(Structure)
-                  
+
                 module Tools = Tools.Make(Structure)
-                  
+
                 include Structure
-                  
+
                 let mk () =
                   let gkeywords = Hashtbl.create 301
                   in
@@ -19145,31 +19165,31 @@ module Struct =
                       warning_verbose = ref true;
                       error_verbose = Camlp4_config.verbose;
                     }
-                  
+
                 let get_filter g = g.gfilter
-                  
+
                 let lex g loc cs = g.glexer loc cs
-                  
+
                 let lex_string g loc str = lex g loc (Stream.of_string str)
-                  
+
                 let filter g ts =
                   Tools.keep_prev_loc (Token.Filter.filter g.gfilter ts)
-                  
+
                 let parse_tokens_after_filter entry ts =
                   Entry.parse_tokens_after_filter entry ts
-                  
+
                 let parse_tokens_before_filter entry ts =
                   parse_tokens_after_filter entry (filter entry.egram ts)
-                  
+
                 let parse entry loc cs =
                   parse_tokens_before_filter entry (lex entry.egram loc cs)
-                  
+
                 let parse_string entry loc str =
                   parse_tokens_before_filter entry
                     (lex_string entry.egram loc str)
-                  
+
                 let delete_rule = Delete.delete_rule
-                  
+
                 let srules e rl =
                   let t =
                     List.fold_left
@@ -19177,45 +19197,45 @@ module Struct =
                          Insert.insert_tree e symbols action tree)
                       DeadEnd rl
                   in Stree t
-                  
+
                 let sfold0 = Fold.sfold0
-                  
+
                 let sfold1 = Fold.sfold1
-                  
+
                 let sfold0sep = Fold.sfold0sep
-                  
+
                 let extend = Insert.extend
-                  
+
               end
-              
+
           end
-          
+
       end
-      
+
   end
-  
+
 module Printers =
   struct
     module DumpCamlp4Ast :
       sig
         module Id : Sig.Id
-          
+
         module Make (Syntax : Sig.Syntax) : Sig.Printer(Syntax.Ast).S
-          
+
       end =
       struct
         module Id =
           struct
             let name = "Camlp4Printers.DumpCamlp4Ast"
-              
+
             let version = Sys.ocaml_version
-              
+
           end
-          
+
         module Make (Syntax : Sig.Syntax) : Sig.Printer(Syntax.Ast).S =
           struct
             include Syntax
-              
+
             let with_open_out_file x f =
               match x with
               | Some file ->
@@ -19223,44 +19243,44 @@ module Printers =
                   in (f oc; flush oc; close_out oc)
               | None ->
                   (set_binary_mode_out stdout true; f stdout; flush stdout)
-              
+
             let dump_ast magic ast oc =
               (output_string oc magic; output_value oc ast)
-              
+
             let print_interf ?input_file:(_) ?output_file ast =
               with_open_out_file output_file
                 (dump_ast Camlp4_config.camlp4_ast_intf_magic_number ast)
-              
+
             let print_implem ?input_file:(_) ?output_file ast =
               with_open_out_file output_file
                 (dump_ast Camlp4_config.camlp4_ast_impl_magic_number ast)
-              
+
           end
-          
+
       end
-      
+
     module DumpOCamlAst :
       sig
         module Id : Sig.Id
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.Ast).S
-          
+
       end =
       struct
         module Id : Sig.Id =
           struct
             let name = "Camlp4Printers.DumpOCamlAst"
-              
+
             let version = Sys.ocaml_version
-              
+
           end
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.Ast).S =
           struct
             include Syntax
-              
+
             module Ast2pt = Struct.Camlp4Ast2OCamlAst.Make(Ast)
-              
+
             let with_open_out_file x f =
               match x with
               | Some file ->
@@ -19268,103 +19288,103 @@ module Printers =
                   in (f oc; flush oc; close_out oc)
               | None ->
                   (set_binary_mode_out stdout true; f stdout; flush stdout)
-              
+
             let dump_pt magic fname pt oc =
               (output_string oc magic;
                output_value oc (if fname = "-" then "" else fname);
                output_value oc pt)
-              
+
             let print_interf ?(input_file = "-") ?output_file ast =
               let pt = Ast2pt.sig_item ast
               in
                 with_open_out_file output_file
                   (dump_pt Camlp4_config.ocaml_ast_intf_magic_number
                      input_file pt)
-              
+
             let print_implem ?(input_file = "-") ?output_file ast =
               let pt = Ast2pt.str_item ast
               in
                 with_open_out_file output_file
                   (dump_pt Camlp4_config.ocaml_ast_impl_magic_number
                      input_file pt)
-              
+
           end
-          
+
       end
-      
+
     module Null :
       sig
         module Id : Sig.Id
-          
+
         module Make (Syntax : Sig.Syntax) : Sig.Printer(Syntax.Ast).S
-          
+
       end =
       struct
         module Id =
           struct
             let name = "Camlp4.Printers.Null"
-              
+
             let version = Sys.ocaml_version
-              
+
           end
-          
+
         module Make (Syntax : Sig.Syntax) =
           struct
             include Syntax
-              
+
             let print_interf ?input_file:(_) ?output_file:(_) _ = ()
-              
+
             let print_implem ?input_file:(_) ?output_file:(_) _ = ()
-              
+
           end
-          
+
       end
-      
+
     module OCaml :
       sig
         module Id : Sig.Id
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) :
           sig
             open Format
-              
+
             include Sig.Camlp4Syntax with module Loc = Syntax.Loc
               and module Token = Syntax.Token and module Ast = Syntax.Ast
               and module Gram = Syntax.Gram
-              
+
             type sep = (unit, formatter, unit) format
-            
+
             type fun_binding = [ | `patt of Ast.patt | `newtype of string ]
-            
+
             val list' :
               (formatter -> 'a -> unit) ->
                 ('b, formatter, unit) format ->
                   (unit, formatter, unit) format ->
                     formatter -> 'a list -> unit
-              
+
             val list :
               (formatter -> 'a -> unit) ->
                 ('b, formatter, unit) format -> formatter -> 'a list -> unit
-              
+
             val lex_string : string -> Token.t
-              
+
             val is_infix : string -> bool
-              
+
             val is_keyword : string -> bool
-              
+
             val ocaml_char : string -> string
-              
+
             val get_expr_args :
               Ast.expr -> Ast.expr list -> (Ast.expr * (Ast.expr list))
-              
+
             val get_patt_args :
               Ast.patt -> Ast.patt list -> (Ast.patt * (Ast.patt list))
-              
+
             val get_ctyp_args :
               Ast.ctyp -> Ast.ctyp list -> (Ast.ctyp * (Ast.ctyp list))
-              
+
             val expr_fun_args : Ast.expr -> ((fun_binding list) * Ast.expr)
-              
+
             class printer :
               ?curry_constr: bool ->
                 ?comments: bool ->
@@ -19479,43 +19499,43 @@ module Printers =
                       method with_constraint :
                         formatter -> Ast.with_constr -> unit
                     end
-              
+
             val with_outfile :
               string option -> (formatter -> 'a -> unit) -> 'a -> unit
-              
+
             val print :
               string option ->
                 (printer -> formatter -> 'a -> unit) -> 'a -> unit
-              
+
           end
-          
+
         module MakeMore (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.
           Ast).S
-          
+
       end =
       struct
         open Format
-          
+
         module Id =
           struct
             let name = "Camlp4.Printers.OCaml"
-              
+
             let version = Sys.ocaml_version
-              
+
           end
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) =
           struct
             include Syntax
-              
+
             type sep = (unit, formatter, unit) format
-            
+
             type fun_binding = [ | `patt of Ast.patt | `newtype of string ]
-            
+
             let pp = fprintf
-              
+
             let cut f = fprintf f "@ "
-              
+
             let list' elt sep sep' f =
               let rec loop =
                 function
@@ -19526,7 +19546,7 @@ module Printers =
                 | [] -> ()
                 | [ x ] -> (elt f x; pp f sep')
                 | x :: xs -> (elt f x; pp f sep'; loop xs)
-              
+
             let list elt sep f =
               let rec loop =
                 function | [] -> () | x :: xs -> (pp f sep; elt f x; loop xs)
@@ -19535,27 +19555,27 @@ module Printers =
                 | [] -> ()
                 | [ x ] -> elt f x
                 | x :: xs -> (elt f x; loop xs)
-              
+
             let rec list_of_meta_list =
               function
               | Ast.LNil -> []
               | Ast.LCons (x, xs) -> x :: (list_of_meta_list xs)
               | Ast.LAnt _ -> assert false
-              
+
             let meta_list elt sep f mxs =
               let xs = list_of_meta_list mxs in list elt sep f xs
-              
+
             module CommentFilter = Struct.CommentFilter.Make(Token)
-              
+
             let comment_filter = CommentFilter.mk ()
-              
+
             let _ = CommentFilter.define (Gram.get_filter ()) comment_filter
-              
+
             module StringSet = Set.Make(String)
-              
+
             let infix_lidents =
               [ "asr"; "land"; "lor"; "lsl"; "lsr"; "lxor"; "mod"; "or" ]
-              
+
             let is_infix =
               let first_chars =
                 [ '='; '<'; '>'; '|'; '&'; '$'; '@'; '^'; '+'; '-'; '*'; '/';
@@ -19566,7 +19586,7 @@ module Printers =
                 fun s ->
                   (StringSet.mem s infixes) ||
                     ((s <> "") && (List.mem s.[0] first_chars))
-              
+
             let is_keyword =
               let keywords =
                 List.fold_right StringSet.add
@@ -19580,17 +19600,17 @@ module Printers =
                     "val"; "virtual"; "when"; "while"; "with" ]
                   StringSet.empty
               in fun s -> StringSet.mem s keywords
-              
+
             module Lexer = Struct.Lexer.Make(Token)
-              
+
             let _ = let module M = ErrorHandler.Register(Lexer.Error) in ()
-              
+
             open Sig
-              
+
             let lexer s =
               Lexer.from_string ~quotations: !Camlp4_config.quotations Loc.
                 ghost s
-              
+
             let lex_string str =
               try
                 let (__strm : _ Stream.t) = lexer str
@@ -19613,26 +19633,26 @@ module Printers =
                     (sprintf
                        "Cannot print %S this identifier does not respect OCaml lexing rules (%s)"
                        str (Lexer.Error.to_string exn))
-              
+
             let ocaml_char x = Char.escaped (Struct.Token.Eval.char x)
-              
+
             let rec get_expr_args a al =
               match a with
               | Ast.ExApp (_, a1, a2) -> get_expr_args a1 (a2 :: al)
               | _ -> (a, al)
-              
+
             let rec get_patt_args a al =
               match a with
               | Ast.PaApp (_, a1, a2) -> get_patt_args a1 (a2 :: al)
               | _ -> (a, al)
-              
+
             let rec get_ctyp_args a al =
               match a with
               | Ast.TyApp (_, a1, a2) -> get_ctyp_args a1 (a2 :: al)
               | _ -> (a, al)
-              
+
             let is_irrefut_patt = Ast.is_irrefut_patt
-              
+
             let rec expr_fun_args =
               function
               | (Ast.ExFun (_, (Ast.McArr (_, p, (Ast.ExNil _), e))) as ge)
@@ -19644,7 +19664,7 @@ module Printers =
               | Ast.ExFUN (_, i, e) ->
                   let (pl, e) = expr_fun_args e in (((`newtype i) :: pl), e)
               | ge -> ([], ge)
-              
+
             let rec class_expr_fun_args =
               function
               | (Ast.CeFun (_, p, ce) as ge) ->
@@ -19653,7 +19673,7 @@ module Printers =
                     (let (pl, ce) = class_expr_fun_args ce in ((p :: pl), ce))
                   else ([], ge)
               | ge -> ([], ge)
-              
+
             let rec do_print_comments_before loc f (__strm : _ Stream.t) =
               match Stream.peek __strm with
               | Some ((comm, comm_loc)) when Loc.strictly_before comm_loc loc
@@ -19663,7 +19683,7 @@ module Printers =
                    let () = f comm comm_loc
                    in do_print_comments_before loc f s)
               | _ -> ()
-              
+
             class printer ?curry_constr:(init_curry_constr = false)
                     ?(comments = true) () =
               object (o)
@@ -20151,7 +20171,7 @@ module Printers =
                       | Ast.ExRec (_, b, (Ast.ExNil _)) ->
                           pp f "@[<hv0>@[<hv2>{%a@]@ }@]" o#record_binding b
                       | Ast.ExRec (_, b, e) ->
-                          pp f "@[<hv0>@[<hv2>{@ (%a)@ with%a@]@ }@]" 
+                          pp f "@[<hv0>@[<hv2>{@ (%a)@ with%a@]@ }@]"
                             o#expr e o#record_binding b
                       | Ast.ExStr (_, s) -> pp f "\"%s\"" s
                       | Ast.ExWhi (_, e1, e2) ->
@@ -20460,7 +20480,7 @@ module Printers =
                       | Ast.SgExc (_, t) ->
                           pp f "@[<2>exception@ %a%(%)@]" o#ctyp t semisep
                       | Ast.SgExt (_, s, t, sl) ->
-                          pp f "@[<2>external@ %a :@ %a =@ %a%(%)@]" 
+                          pp f "@[<2>external@ %a :@ %a =@ %a%(%)@]"
                             o#var s o#ctyp t (meta_list o#quoted_string "@ ")
                             sl semisep
                       | Ast.SgMod ((_, name, Ast.MtAlias ((_, id)))) ->
@@ -20523,7 +20543,7 @@ module Printers =
                           pp f "@[<2>exception@ %a =@ %a%(%)@]" o#ctyp t
                             o#ident sl semisep
                       | Ast.StExt (_, s, t, sl) ->
-                          pp f "@[<2>external@ %a :@ %a =@ %a%(%)@]" 
+                          pp f "@[<2>external@ %a :@ %a =@ %a%(%)@]"
                             o#var s o#ctyp t (meta_list o#quoted_string "@ ")
                             sl semisep
                       | Ast.StMod (_, s1, (Ast.MeFun (_, s2, mt1, me))) ->
@@ -20614,7 +20634,7 @@ module Printers =
                       | Ast.WcTyS (_, t1, t2) ->
                           pp f "@[<2>type@ %a :=@ %a@]" o#ctyp t1 o#ctyp t2
                       | Ast.WcMoS (_, i1, i2) ->
-                          pp f "@[<2>module@ %a :=@ %a@]" o#ident i1 
+                          pp f "@[<2>module@ %a :=@ %a@]" o#ident i1
                             o#ident i2
                       | Ast.WcAnd (_, wc1, wc2) ->
                           (o#with_constraint f wc1;
@@ -20722,7 +20742,7 @@ module Printers =
                       | Ast.CtCon (_, Ast.ViNil, i, (Ast.TyNil _)) ->
                           pp f "@[<2>%a@]" o#ident i
                       | Ast.CtCon (_, Ast.ViNil, i, t) ->
-                          pp f "@[<2>[@,%a@]@,]@ %a" o#class_params t 
+                          pp f "@[<2>[@,%a@]@,]@ %a" o#class_params t
                             o#ident i
                       | Ast.CtCon (_, Ast.ViVirtual, (Ast.IdLid (_, i)),
                           (Ast.TyNil _)) -> pp f "@[<2>virtual@ %a@]" o#var i
@@ -20836,7 +20856,7 @@ module Printers =
                     | st -> pp f "@[<v0>%a@]@." o#str_item st
                 method interf = fun f sg -> pp f "@[<v0>%a@]@." o#sig_item sg
               end
-              
+
             let with_outfile output_file fct arg =
               let call close f =
                 ((try fct f arg with | exn -> (close (); raise exn));
@@ -20848,33 +20868,33 @@ module Printers =
                     let oc = open_out s in
                     let f = formatter_of_out_channel oc
                     in call (fun () -> close_out oc) f
-              
+
             let print output_file fct =
               let o = new printer () in with_outfile output_file (fct o)
-              
+
             let print_interf ?input_file:(_) ?output_file sg =
               print output_file (fun o -> o#interf) sg
-              
+
             let print_implem ?input_file:(_) ?output_file st =
               print output_file (fun o -> o#implem) st
-              
+
           end
-          
+
         module MakeMore (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.
           Ast).S =
           struct
             include Make(Syntax)
-              
+
             let semisep : sep ref = ref ("@\n" : sep)
-              
+
             let margin = ref 78
-              
+
             let comments = ref true
-              
+
             let locations = ref false
-              
+
             let curry_constr = ref false
-              
+
             let print output_file fct =
               let o =
                 new printer ~comments: !comments ~curry_constr: !curry_constr
@@ -20886,104 +20906,104 @@ module Printers =
                   (fun f ->
                      let () = Format.pp_set_margin f !margin
                      in Format.fprintf f "@[<v0>%a@]@." (fct o))
-              
+
             let print_interf ?input_file:(_) ?output_file sg =
               print output_file (fun o -> o#interf) sg
-              
+
             let print_implem ?input_file:(_) ?output_file st =
               print output_file (fun o -> o#implem) st
-              
+
             let check_sep s =
               if String.contains s '%'
               then failwith "-sep Format error, % found in string"
               else (Obj.magic (Struct.Token.Eval.string s : string) : sep)
-              
+
             let _ =
               Options.add "-l" (Arg.Int (fun i -> margin := i))
                 "<length> line length for pretty printing."
-              
+
             let _ =
               Options.add "-ss" (Arg.Unit (fun () -> semisep := ";;"))
                 " Print double semicolons."
-              
+
             let _ =
               Options.add "-no_ss" (Arg.Unit (fun () -> semisep := ""))
                 " Do not print double semicolons (default)."
-              
+
             let _ =
               Options.add "-sep"
                 (Arg.String (fun s -> semisep := check_sep s))
                 " Use this string between phrases."
-              
+
             let _ =
               Options.add "-curry-constr" (Arg.Set curry_constr)
                 "Use currified constructors."
-              
+
             let _ =
               Options.add "-no_comments" (Arg.Clear comments)
                 "Do not add comments."
-              
+
             let _ =
               Options.add "-add_locations" (Arg.Set locations)
                 "Add locations as comment."
-              
+
           end
-          
+
       end
-      
+
     module OCamlr :
       sig
         module Id : Sig.Id
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) :
           sig
             open Format
-              
+
             include Sig.Camlp4Syntax with module Loc = Syntax.Loc
               and module Token = Syntax.Token and module Ast = Syntax.Ast
               and module Gram = Syntax.Gram
-              
+
             class printer :
               ?curry_constr: bool ->
                 ?comments: bool ->
                   unit -> object ('a) inherit OCaml.Make(Syntax).printer end
-              
+
             val with_outfile :
               string option -> (formatter -> 'a -> unit) -> 'a -> unit
-              
+
             val print :
               string option ->
                 (printer -> formatter -> 'a -> unit) -> 'a -> unit
-              
+
           end
-          
+
         module MakeMore (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.
           Ast).S
-          
+
       end =
       struct
         open Format
-          
+
         module Id =
           struct
             let name = "Camlp4.Printers.OCamlr"
-              
+
             let version = Sys.ocaml_version
-              
+
           end
-          
+
         module Make (Syntax : Sig.Camlp4Syntax) =
           struct
             include Syntax
-              
+
             open Sig
-              
+
             module PP_o = OCaml.Make(Syntax)
-              
+
             open PP_o
-              
+
             let pp = fprintf
-              
+
             let is_keyword =
               let keywords = [ "where" ]
               and not_keywords = [ "false"; "function"; "true"; "val" ]
@@ -20991,7 +21011,7 @@ module Printers =
                 fun s ->
                   (not (List.mem s not_keywords)) &&
                     ((is_keyword s) || (List.mem s keywords))
-              
+
             class printer ?curry_constr:(init_curry_constr = true)
                     ?(comments = true) () =
               object (o)
@@ -21287,33 +21307,33 @@ module Printers =
                             o#class_params t
                       | ce -> super#class_expr f ce
               end
-              
+
             let with_outfile = with_outfile
-              
+
             let print output_file fct =
               let o = new printer () in with_outfile output_file (fct o)
-              
+
             let print_interf ?input_file:(_) ?output_file sg =
               print output_file (fun o -> o#interf) sg
-              
+
             let print_implem ?input_file:(_) ?output_file st =
               print output_file (fun o -> o#implem) st
-              
+
           end
-          
+
         module MakeMore (Syntax : Sig.Camlp4Syntax) : Sig.Printer(Syntax.
           Ast).S =
           struct
             include Make(Syntax)
-              
+
             let margin = ref 78
-              
+
             let comments = ref true
-              
+
             let locations = ref false
-              
+
             let curry_constr = ref true
-              
+
             let print output_file fct =
               let o =
                 new printer ~comments: !comments ~curry_constr: !curry_constr
@@ -21324,31 +21344,31 @@ module Printers =
                   (fun f ->
                      let () = Format.pp_set_margin f !margin
                      in Format.fprintf f "@[<v0>%a@]@." (fct o))
-              
+
             let print_interf ?input_file:(_) ?output_file sg =
               print output_file (fun o -> o#interf) sg
-              
+
             let print_implem ?input_file:(_) ?output_file st =
               print output_file (fun o -> o#implem) st
-              
+
             let _ =
               Options.add "-l" (Arg.Int (fun i -> margin := i))
                 "<length> line length for pretty printing."
-              
+
             let _ =
               Options.add "-no_comments" (Arg.Clear comments)
                 "Do not add comments."
-              
+
             let _ =
               Options.add "-add_locations" (Arg.Set locations)
                 "Add locations as comment."
-              
+
           end
-          
+
       end
-      
+
   end
-  
+
 module OCamlInitSyntax =
   struct
     module Make
@@ -21362,384 +21382,384 @@ module OCamlInitSyntax =
       and module Quotation = Quotation =
       struct
         module Loc = Ast.Loc
-          
+
         module Ast = Ast
-          
+
         module Gram = Gram
-          
+
         module Token = Gram.Token
-          
+
         open Sig
-          
+
         type warning = Loc.t -> string -> unit
-        
+
         let default_warning loc txt =
           Format.eprintf "<W> %a: %s@." Loc.print loc txt
-          
+
         let current_warning = ref default_warning
-          
+
         let print_warning loc txt = !current_warning loc txt
-          
+
         let a_CHAR = Gram.Entry.mk "a_CHAR"
-          
+
         let a_FLOAT = Gram.Entry.mk "a_FLOAT"
-          
+
         let a_INT = Gram.Entry.mk "a_INT"
-          
+
         let a_INT32 = Gram.Entry.mk "a_INT32"
-          
+
         let a_INT64 = Gram.Entry.mk "a_INT64"
-          
+
         let a_LABEL = Gram.Entry.mk "a_LABEL"
-          
+
         let a_LIDENT = Gram.Entry.mk "a_LIDENT"
-          
+
         let a_NATIVEINT = Gram.Entry.mk "a_NATIVEINT"
-          
+
         let a_OPTLABEL = Gram.Entry.mk "a_OPTLABEL"
-          
+
         let a_STRING = Gram.Entry.mk "a_STRING"
-          
+
         let a_UIDENT = Gram.Entry.mk "a_UIDENT"
-          
+
         let a_ident = Gram.Entry.mk "a_ident"
-          
+
         let amp_ctyp = Gram.Entry.mk "amp_ctyp"
-          
+
         let and_ctyp = Gram.Entry.mk "and_ctyp"
-          
+
         let match_case = Gram.Entry.mk "match_case"
-          
+
         let match_case0 = Gram.Entry.mk "match_case0"
-          
+
         let binding = Gram.Entry.mk "binding"
-          
+
         let class_declaration = Gram.Entry.mk "class_declaration"
-          
+
         let class_description = Gram.Entry.mk "class_description"
-          
+
         let class_expr = Gram.Entry.mk "class_expr"
-          
+
         let class_fun_binding = Gram.Entry.mk "class_fun_binding"
-          
+
         let class_fun_def = Gram.Entry.mk "class_fun_def"
-          
+
         let class_info_for_class_expr =
           Gram.Entry.mk "class_info_for_class_expr"
-          
+
         let class_info_for_class_type =
           Gram.Entry.mk "class_info_for_class_type"
-          
+
         let class_longident = Gram.Entry.mk "class_longident"
-          
+
         let class_longident_and_param =
           Gram.Entry.mk "class_longident_and_param"
-          
+
         let class_name_and_param = Gram.Entry.mk "class_name_and_param"
-          
+
         let class_sig_item = Gram.Entry.mk "class_sig_item"
-          
+
         let class_signature = Gram.Entry.mk "class_signature"
-          
+
         let class_str_item = Gram.Entry.mk "class_str_item"
-          
+
         let class_structure = Gram.Entry.mk "class_structure"
-          
+
         let class_type = Gram.Entry.mk "class_type"
-          
+
         let class_type_declaration = Gram.Entry.mk "class_type_declaration"
-          
+
         let class_type_longident = Gram.Entry.mk "class_type_longident"
-          
+
         let class_type_longident_and_param =
           Gram.Entry.mk "class_type_longident_and_param"
-          
+
         let class_type_plus = Gram.Entry.mk "class_type_plus"
-          
+
         let comma_ctyp = Gram.Entry.mk "comma_ctyp"
-          
+
         let comma_expr = Gram.Entry.mk "comma_expr"
-          
+
         let comma_ipatt = Gram.Entry.mk "comma_ipatt"
-          
+
         let comma_patt = Gram.Entry.mk "comma_patt"
-          
+
         let comma_type_parameter = Gram.Entry.mk "comma_type_parameter"
-          
+
         let constrain = Gram.Entry.mk "constrain"
-          
+
         let constructor_arg_list = Gram.Entry.mk "constructor_arg_list"
-          
+
         let constructor_declaration = Gram.Entry.mk "constructor_declaration"
-          
+
         let constructor_declarations =
           Gram.Entry.mk "constructor_declarations"
-          
+
         let ctyp = Gram.Entry.mk "ctyp"
-          
+
         let cvalue_binding = Gram.Entry.mk "cvalue_binding"
-          
+
         let direction_flag = Gram.Entry.mk "direction_flag"
-          
+
         let direction_flag_quot = Gram.Entry.mk "direction_flag_quot"
-          
+
         let dummy = Gram.Entry.mk "dummy"
-          
+
         let entry_eoi = Gram.Entry.mk "entry_eoi"
-          
+
         let eq_expr = Gram.Entry.mk "eq_expr"
-          
+
         let expr = Gram.Entry.mk "expr"
-          
+
         let expr_eoi = Gram.Entry.mk "expr_eoi"
-          
+
         let field_expr = Gram.Entry.mk "field_expr"
-          
+
         let field_expr_list = Gram.Entry.mk "field_expr_list"
-          
+
         let fun_binding = Gram.Entry.mk "fun_binding"
-          
+
         let fun_def = Gram.Entry.mk "fun_def"
-          
+
         let ident = Gram.Entry.mk "ident"
-          
+
         let implem = Gram.Entry.mk "implem"
-          
+
         let interf = Gram.Entry.mk "interf"
-          
+
         let ipatt = Gram.Entry.mk "ipatt"
-          
+
         let ipatt_tcon = Gram.Entry.mk "ipatt_tcon"
-          
+
         let label = Gram.Entry.mk "label"
-          
+
         let label_declaration = Gram.Entry.mk "label_declaration"
-          
+
         let label_declaration_list = Gram.Entry.mk "label_declaration_list"
-          
+
         let label_expr = Gram.Entry.mk "label_expr"
-          
+
         let label_expr_list = Gram.Entry.mk "label_expr_list"
-          
+
         let label_ipatt = Gram.Entry.mk "label_ipatt"
-          
+
         let label_ipatt_list = Gram.Entry.mk "label_ipatt_list"
-          
+
         let label_longident = Gram.Entry.mk "label_longident"
-          
+
         let label_patt = Gram.Entry.mk "label_patt"
-          
+
         let label_patt_list = Gram.Entry.mk "label_patt_list"
-          
+
         let labeled_ipatt = Gram.Entry.mk "labeled_ipatt"
-          
+
         let let_binding = Gram.Entry.mk "let_binding"
-          
+
         let meth_list = Gram.Entry.mk "meth_list"
-          
+
         let meth_decl = Gram.Entry.mk "meth_decl"
-          
+
         let module_binding = Gram.Entry.mk "module_binding"
-          
+
         let module_binding0 = Gram.Entry.mk "module_binding0"
-          
+
         let module_declaration = Gram.Entry.mk "module_declaration"
-          
+
         let module_expr = Gram.Entry.mk "module_expr"
-          
+
         let module_longident = Gram.Entry.mk "module_longident"
-          
+
         let module_longident_with_app =
           Gram.Entry.mk "module_longident_with_app"
-          
+
         let module_rec_declaration = Gram.Entry.mk "module_rec_declaration"
-          
+
         let module_type = Gram.Entry.mk "module_type"
-          
+
         let package_type = Gram.Entry.mk "package_type"
-          
+
         let more_ctyp = Gram.Entry.mk "more_ctyp"
-          
+
         let name_tags = Gram.Entry.mk "name_tags"
-          
+
         let opt_as_lident = Gram.Entry.mk "opt_as_lident"
-          
+
         let opt_class_self_patt = Gram.Entry.mk "opt_class_self_patt"
-          
+
         let opt_class_self_type = Gram.Entry.mk "opt_class_self_type"
-          
+
         let opt_class_signature = Gram.Entry.mk "opt_class_signature"
-          
+
         let opt_class_structure = Gram.Entry.mk "opt_class_structure"
-          
+
         let opt_comma_ctyp = Gram.Entry.mk "opt_comma_ctyp"
-          
+
         let opt_dot_dot = Gram.Entry.mk "opt_dot_dot"
-          
+
         let row_var_flag_quot = Gram.Entry.mk "row_var_flag_quot"
-          
+
         let opt_eq_ctyp = Gram.Entry.mk "opt_eq_ctyp"
-          
+
         let opt_expr = Gram.Entry.mk "opt_expr"
-          
+
         let opt_meth_list = Gram.Entry.mk "opt_meth_list"
-          
+
         let opt_mutable = Gram.Entry.mk "opt_mutable"
-          
+
         let mutable_flag_quot = Gram.Entry.mk "mutable_flag_quot"
-          
+
         let opt_polyt = Gram.Entry.mk "opt_polyt"
-          
+
         let opt_private = Gram.Entry.mk "opt_private"
-          
+
         let private_flag_quot = Gram.Entry.mk "private_flag_quot"
-          
+
         let opt_rec = Gram.Entry.mk "opt_rec"
-          
+
         let rec_flag_quot = Gram.Entry.mk "rec_flag_quot"
-          
+
         let opt_sig_items = Gram.Entry.mk "opt_sig_items"
-          
+
         let opt_str_items = Gram.Entry.mk "opt_str_items"
-          
+
         let opt_virtual = Gram.Entry.mk "opt_virtual"
-          
+
         let virtual_flag_quot = Gram.Entry.mk "virtual_flag_quot"
-          
+
         let opt_override = Gram.Entry.mk "opt_override"
-          
+
         let override_flag_quot = Gram.Entry.mk "override_flag_quot"
-          
+
         let opt_when_expr = Gram.Entry.mk "opt_when_expr"
-          
+
         let patt = Gram.Entry.mk "patt"
-          
+
         let patt_as_patt_opt = Gram.Entry.mk "patt_as_patt_opt"
-          
+
         let patt_eoi = Gram.Entry.mk "patt_eoi"
-          
+
         let patt_tcon = Gram.Entry.mk "patt_tcon"
-          
+
         let phrase = Gram.Entry.mk "phrase"
-          
+
         let poly_type = Gram.Entry.mk "poly_type"
-          
+
         let row_field = Gram.Entry.mk "row_field"
-          
+
         let sem_expr = Gram.Entry.mk "sem_expr"
-          
+
         let sem_expr_for_list = Gram.Entry.mk "sem_expr_for_list"
-          
+
         let sem_patt = Gram.Entry.mk "sem_patt"
-          
+
         let sem_patt_for_list = Gram.Entry.mk "sem_patt_for_list"
-          
+
         let semi = Gram.Entry.mk "semi"
-          
+
         let sequence = Gram.Entry.mk "sequence"
-          
+
         let do_sequence = Gram.Entry.mk "do_sequence"
-          
+
         let sig_item = Gram.Entry.mk "sig_item"
-          
+
         let sig_items = Gram.Entry.mk "sig_items"
-          
+
         let star_ctyp = Gram.Entry.mk "star_ctyp"
-          
+
         let str_item = Gram.Entry.mk "str_item"
-          
+
         let str_items = Gram.Entry.mk "str_items"
-          
+
         let top_phrase = Gram.Entry.mk "top_phrase"
-          
+
         let type_constraint = Gram.Entry.mk "type_constraint"
-          
+
         let type_declaration = Gram.Entry.mk "type_declaration"
-          
+
         let type_ident_and_parameters =
           Gram.Entry.mk "type_ident_and_parameters"
-          
+
         let type_kind = Gram.Entry.mk "type_kind"
-          
+
         let type_longident = Gram.Entry.mk "type_longident"
-          
+
         let type_longident_and_parameters =
           Gram.Entry.mk "type_longident_and_parameters"
-          
+
         let type_parameter = Gram.Entry.mk "type_parameter"
-          
+
         let type_parameters = Gram.Entry.mk "type_parameters"
-          
+
         let typevars = Gram.Entry.mk "typevars"
-          
+
         let use_file = Gram.Entry.mk "use_file"
-          
+
         let val_longident = Gram.Entry.mk "val_longident"
-          
+
         let value_let = Gram.Entry.mk "value_let"
-          
+
         let value_val = Gram.Entry.mk "value_val"
-          
+
         let with_constr = Gram.Entry.mk "with_constr"
-          
+
         let expr_quot = Gram.Entry.mk "quotation of expression"
-          
+
         let patt_quot = Gram.Entry.mk "quotation of pattern"
-          
+
         let ctyp_quot = Gram.Entry.mk "quotation of type"
-          
+
         let str_item_quot = Gram.Entry.mk "quotation of structure item"
-          
+
         let sig_item_quot = Gram.Entry.mk "quotation of signature item"
-          
+
         let class_str_item_quot =
           Gram.Entry.mk "quotation of class structure item"
-          
+
         let class_sig_item_quot =
           Gram.Entry.mk "quotation of class signature item"
-          
+
         let module_expr_quot = Gram.Entry.mk "quotation of module expression"
-          
+
         let module_type_quot = Gram.Entry.mk "quotation of module type"
-          
+
         let class_type_quot = Gram.Entry.mk "quotation of class type"
-          
+
         let class_expr_quot = Gram.Entry.mk "quotation of class expression"
-          
+
         let with_constr_quot = Gram.Entry.mk "quotation of with constraint"
-          
+
         let binding_quot = Gram.Entry.mk "quotation of binding"
-          
+
         let rec_binding_quot = Gram.Entry.mk "quotation of record binding"
-          
+
         let match_case_quot =
           Gram.Entry.mk "quotation of match_case (try/match/function case)"
-          
+
         let module_binding_quot =
           Gram.Entry.mk "quotation of module rec binding"
-          
+
         let ident_quot = Gram.Entry.mk "quotation of identifier"
-          
+
         let prefixop =
           Gram.Entry.mk "prefix operator (start with '!', '?', '~')"
-          
+
         let infixop0 =
           Gram.Entry.mk
             "infix operator (level 0) (comparison operators, and some others)"
-          
+
         let infixop1 =
           Gram.Entry.mk "infix operator (level 1) (start with '^', '@')"
-          
+
         let infixop2 =
           Gram.Entry.mk "infix operator (level 2) (start with '+', '-')"
-          
+
         let infixop3 =
           Gram.Entry.mk "infix operator (level 3) (start with '*', '/', '%')"
-          
+
         let infixop4 =
           Gram.Entry.mk
             "infix operator (level 4) (start with \"**\") (right assoc)"
-          
+
         let _ =
           Gram.extend (top_phrase : 'top_phrase Gram.Entry.t)
             ((fun () ->
@@ -21754,19 +21774,19 @@ module OCamlInitSyntax =
                              | EOI -> (None : 'top_phrase)
                              | _ -> assert false))) ]) ]))
                ())
-          
+
         module AntiquotSyntax =
           struct
             module Loc = Ast.Loc
-              
+
             module Ast = Sig.Camlp4AstToAst(Ast)
-              
+
             module Gram = Gram
-              
+
             let antiquot_expr = Gram.Entry.mk "antiquot_expr"
-              
+
             let antiquot_patt = Gram.Entry.mk "antiquot_patt"
-              
+
             let _ =
               (Gram.extend (antiquot_expr : 'antiquot_expr Gram.Entry.t)
                  ((fun () ->
@@ -21800,15 +21820,15 @@ module OCamlInitSyntax =
                                   | EOI -> (x : 'antiquot_patt)
                                   | _ -> assert false))) ]) ]))
                     ()))
-              
+
             let parse_expr loc str = Gram.parse_string antiquot_expr loc str
-              
+
             let parse_patt loc str = Gram.parse_string antiquot_patt loc str
-              
+
           end
-          
+
         module Quotation = Quotation
-          
+
         let wrap directive_handler pa init_loc cs =
           let rec loop loc =
             let (pl, stopped_at_directive) = pa loc cs
@@ -21825,25 +21845,25 @@ module OCamlInitSyntax =
                   in (List.rev pl) @ (loop new_loc)
               | None -> pl
           in loop init_loc
-          
+
         let parse_implem ?(directive_handler = fun _ -> None) _loc cs =
           let l = wrap directive_handler (Gram.parse implem) _loc cs
           in Ast.stSem_of_list l
-          
+
         let parse_interf ?(directive_handler = fun _ -> None) _loc cs =
           let l = wrap directive_handler (Gram.parse interf) _loc cs
           in Ast.sgSem_of_list l
-          
+
         let print_interf ?input_file:(_) ?output_file:(_) _ =
           failwith "No interface printer"
-          
+
         let print_implem ?input_file:(_) ?output_file:(_) _ =
           failwith "No implementation printer"
-          
+
       end
-      
+
   end
-  
+
 module PreCast :
   sig
     type camlp4_token =
@@ -21869,57 +21889,57 @@ module PreCast :
         | NEWLINE
         | LINE_DIRECTIVE of int * string option
         | EOI
-    
+
     module Id : Sig.Id
-      
+
     module Loc : Sig.Loc
-      
+
     module Ast : Sig.Camlp4Ast with module Loc = Loc
-      
+
     module Token : Sig.Token with module Loc = Loc and type t = camlp4_token
-      
+
     module Lexer : Sig.Lexer with module Loc = Loc and module Token = Token
-      
+
     module Gram : Sig.Grammar.Static with module Loc = Loc
       and module Token = Token
-      
+
     module Quotation :
       Sig.Quotation with module Ast = Sig.Camlp4AstToAst(Ast)
-      
+
     module DynLoader : Sig.DynLoader
-      
+
     module AstFilters : Sig.AstFilters with module Ast = Ast
-      
+
     module Syntax : Sig.Camlp4Syntax with module Loc = Loc
       and module Token = Token and module Ast = Ast and module Gram = Gram
       and module Quotation = Quotation
-      
+
     module Printers :
       sig
         module OCaml : Sig.Printer(Ast).S
-          
+
         module OCamlr : Sig.Printer(Ast).S
-          
+
         module DumpOCamlAst : Sig.Printer(Ast).S
-          
+
         module DumpCamlp4Ast : Sig.Printer(Ast).S
-          
+
         module Null : Sig.Printer(Ast).S
-          
+
       end
-      
+
     module MakeGram (Lexer : Sig.Lexer with module Loc = Loc) :
       Sig.Grammar.Static with module Loc = Loc and module Token = Lexer.Token
-      
+
     module MakeSyntax (U : sig  end) : Sig.Syntax
-      
+
   end =
   struct
     module Id =
       struct let name = "Camlp4.PreCast"
                 let version = Sys.ocaml_version
                    end
-      
+
     type camlp4_token =
       Sig.camlp4_token =
         | KEYWORD of string
@@ -21943,222 +21963,222 @@ module PreCast :
         | NEWLINE
         | LINE_DIRECTIVE of int * string option
         | EOI
-    
+
     module Loc = Struct.Loc
-      
+
     module Ast = Struct.Camlp4Ast.Make(Loc)
-      
+
     module Token = Struct.Token.Make(Loc)
-      
+
     module Lexer = Struct.Lexer.Make(Token)
-      
+
     module Gram = Struct.Grammar.Static.Make(Lexer)
-      
+
     module DynLoader = Struct.DynLoader
-      
+
     module Quotation = Struct.Quotation.Make(Ast)
-      
+
     module MakeSyntax (U : sig  end) =
       OCamlInitSyntax.Make(Ast)(Gram)(Quotation)
-      
+
     module Syntax = MakeSyntax(struct  end)
-      
+
     module AstFilters = Struct.AstFilters.Make(Ast)
-      
+
     module MakeGram = Struct.Grammar.Static.Make
-      
+
     module Printers =
       struct
         module OCaml = Printers.OCaml.Make(Syntax)
-          
+
         module OCamlr = Printers.OCamlr.Make(Syntax)
-          
+
         module DumpOCamlAst = Printers.DumpOCamlAst.Make(Syntax)
-          
+
         module DumpCamlp4Ast = Printers.DumpCamlp4Ast.Make(Syntax)
-          
+
         module Null = Printers.Null.Make(Syntax)
-          
+
       end
-      
+
   end
-  
+
 module Register :
   sig
     module Plugin
       (Id : Sig.Id) (Plugin : functor (Unit : sig  end) -> sig  end) :
       sig  end
-      
+
     module SyntaxPlugin
       (Id : Sig.Id) (SyntaxPlugin : functor (Syn : Sig.Syntax) -> sig  end) :
       sig  end
-      
+
     module SyntaxExtension
       (Id : Sig.Id) (SyntaxExtension : Sig.SyntaxExtension) : sig  end
-      
+
     module OCamlSyntaxExtension
       (Id : Sig.Id)
       (SyntaxExtension :
         functor (Syntax : Sig.Camlp4Syntax) -> Sig.Camlp4Syntax) :
       sig  end
-      
+
     type 'a parser_fun =
       ?directive_handler: ('a -> 'a option) ->
         PreCast.Loc.t -> char Stream.t -> 'a
-    
+
     val register_str_item_parser : PreCast.Ast.str_item parser_fun -> unit
-      
+
     val register_sig_item_parser : PreCast.Ast.sig_item parser_fun -> unit
-      
+
     val register_parser :
       PreCast.Ast.str_item parser_fun ->
         PreCast.Ast.sig_item parser_fun -> unit
-      
+
     val current_parser :
       unit ->
         ((PreCast.Ast.str_item parser_fun) *
          (PreCast.Ast.sig_item parser_fun))
-      
+
     module Parser
       (Id : Sig.Id) (Maker : functor (Ast : Sig.Ast) -> Sig.Parser(Ast).S) :
       sig  end
-      
+
     module OCamlParser
       (Id : Sig.Id)
-      (Maker : functor (Ast : Sig.Camlp4Ast) -> Sig.Parser(Ast).S) : 
+      (Maker : functor (Ast : Sig.Camlp4Ast) -> Sig.Parser(Ast).S) :
       sig  end
-      
+
     module OCamlPreCastParser
       (Id : Sig.Id) (Parser : Sig.Parser(PreCast.Ast).S) : sig  end
-      
+
     type 'a printer_fun =
       ?input_file: string -> ?output_file: string -> 'a -> unit
-    
+
     val register_str_item_printer : PreCast.Ast.str_item printer_fun -> unit
-      
+
     val register_sig_item_printer : PreCast.Ast.sig_item printer_fun -> unit
-      
+
     val register_printer :
       PreCast.Ast.str_item printer_fun ->
         PreCast.Ast.sig_item printer_fun -> unit
-      
+
     val current_printer :
       unit ->
         ((PreCast.Ast.str_item printer_fun) *
          (PreCast.Ast.sig_item printer_fun))
-      
+
     module Printer
       (Id : Sig.Id)
       (Maker : functor (Syn : Sig.Syntax) -> Sig.Printer(Syn.Ast).S) :
       sig  end
-      
+
     module OCamlPrinter
       (Id : Sig.Id)
       (Maker : functor (Syn : Sig.Camlp4Syntax) -> Sig.Printer(Syn.Ast).S) :
       sig  end
-      
+
     module OCamlPreCastPrinter
       (Id : Sig.Id) (Printer : Sig.Printer(PreCast.Ast).S) : sig  end
-      
+
     module AstFilter
       (Id : Sig.Id) (Maker : functor (F : Sig.AstFilters) -> sig  end) :
       sig  end
-      
+
     val declare_dyn_module : string -> (unit -> unit) -> unit
-      
+
     val iter_and_take_callbacks : ((string * (unit -> unit)) -> unit) -> unit
-      
+
     val loaded_modules : (string list) ref
-      
+
     module CurrentParser : Sig.Parser(PreCast.Ast).S
-      
+
     module CurrentPrinter : Sig.Printer(PreCast.Ast).S
-      
+
     val enable_ocaml_printer : unit -> unit
-      
+
     val enable_ocamlr_printer : unit -> unit
-      
+
     val enable_null_printer : unit -> unit
-      
+
     val enable_dump_ocaml_ast_printer : unit -> unit
-      
+
     val enable_dump_camlp4_ast_printer : unit -> unit
-      
+
   end =
   struct
     module PP = Printers
-      
+
     open PreCast
-      
+
     type 'a parser_fun =
       ?directive_handler: ('a -> 'a option) ->
         PreCast.Loc.t -> char Stream.t -> 'a
-    
+
     type 'a printer_fun =
       ?input_file: string -> ?output_file: string -> 'a -> unit
-    
+
     let sig_item_parser =
       ref (fun ?directive_handler:(_) _ _ -> failwith "No interface parser")
-      
+
     let str_item_parser =
       ref
         (fun ?directive_handler:(_) _ _ ->
            failwith "No implementation parser")
-      
+
     let sig_item_printer =
       ref
         (fun ?input_file:(_) ?output_file:(_) _ ->
            failwith "No interface printer")
-      
+
     let str_item_printer =
       ref
         (fun ?input_file:(_) ?output_file:(_) _ ->
            failwith "No implementation printer")
-      
+
     let callbacks = Queue.create ()
-      
+
     let loaded_modules = ref []
-      
+
     let iter_and_take_callbacks f =
       let rec loop () = loop (f (Queue.take callbacks))
       in try loop () with | Queue.Empty -> ()
-      
+
     let declare_dyn_module m f =
       (loaded_modules := m :: !loaded_modules; Queue.add (m, f) callbacks)
-      
+
     let register_str_item_parser f = str_item_parser := f
-      
+
     let register_sig_item_parser f = sig_item_parser := f
-      
+
     let register_parser f g = (str_item_parser := f; sig_item_parser := g)
-      
+
     let current_parser () = ((!str_item_parser), (!sig_item_parser))
-      
+
     let register_str_item_printer f = str_item_printer := f
-      
+
     let register_sig_item_printer f = sig_item_printer := f
-      
+
     let register_printer f g = (str_item_printer := f; sig_item_printer := g)
-      
+
     let current_printer () = ((!str_item_printer), (!sig_item_printer))
-      
+
     module Plugin
       (Id : Sig.Id) (Maker : functor (Unit : sig  end) -> sig  end) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(struct  end) in ())
-          
+
       end
-      
+
     module SyntaxExtension (Id : Sig.Id) (Maker : Sig.SyntaxExtension) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(Syntax) in ())
-          
+
       end
-      
+
     module OCamlSyntaxExtension
       (Id : Sig.Id)
       (Maker : functor (Syn : Sig.Camlp4Syntax) -> Sig.Camlp4Syntax) =
@@ -22166,18 +22186,18 @@ module Register :
         let _ =
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(Syntax) in ())
-          
+
       end
-      
+
     module SyntaxPlugin
       (Id : Sig.Id) (Maker : functor (Syn : Sig.Syntax) -> sig  end) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(Syntax) in ())
-          
+
       end
-      
+
     module Printer
       (Id : Sig.Id)
       (Maker : functor (Syn : Sig.Syntax) -> Sig.Printer(Syn.Ast).S) =
@@ -22186,9 +22206,9 @@ module Register :
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(Syntax)
                in register_printer M.print_implem M.print_interf)
-          
+
       end
-      
+
     module OCamlPrinter
       (Id : Sig.Id)
       (Maker : functor (Syn : Sig.Camlp4Syntax) -> Sig.Printer(Syn.Ast).S) =
@@ -22197,18 +22217,18 @@ module Register :
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(Syntax)
                in register_printer M.print_implem M.print_interf)
-          
+
       end
-      
+
     module OCamlPreCastPrinter
       (Id : Sig.Id) (P : Sig.Printer(PreCast.Ast).S) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> register_printer P.print_implem P.print_interf)
-          
+
       end
-      
+
     module Parser
       (Id : Sig.Id) (Maker : functor (Ast : Sig.Ast) -> Sig.Parser(Ast).S) =
       struct
@@ -22216,9 +22236,9 @@ module Register :
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(PreCast.Ast)
                in register_parser M.parse_implem M.parse_interf)
-          
+
       end
-      
+
     module OCamlParser
       (Id : Sig.Id)
       (Maker : functor (Ast : Sig.Camlp4Ast) -> Sig.Parser(Ast).S) =
@@ -22227,71 +22247,71 @@ module Register :
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(PreCast.Ast)
                in register_parser M.parse_implem M.parse_interf)
-          
+
       end
-      
+
     module OCamlPreCastParser (Id : Sig.Id) (P : Sig.Parser(PreCast.Ast).S) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> register_parser P.parse_implem P.parse_interf)
-          
+
       end
-      
+
     module AstFilter
       (Id : Sig.Id) (Maker : functor (F : Sig.AstFilters) -> sig  end) =
       struct
         let _ =
           declare_dyn_module Id.name
             (fun _ -> let module M = Maker(AstFilters) in ())
-          
+
       end
-      
+
     let _ = sig_item_parser := Syntax.parse_interf
-      
+
     let _ = str_item_parser := Syntax.parse_implem
-      
+
     module CurrentParser =
       struct
         module Ast = Ast
-          
+
         let parse_interf ?directive_handler loc strm =
           !sig_item_parser ?directive_handler loc strm
-          
+
         let parse_implem ?directive_handler loc strm =
           !str_item_parser ?directive_handler loc strm
-          
+
       end
-      
+
     module CurrentPrinter =
       struct
         module Ast = Ast
-          
+
         let print_interf ?input_file ?output_file ast =
           !sig_item_printer ?input_file ?output_file ast
-          
+
         let print_implem ?input_file ?output_file ast =
           !str_item_printer ?input_file ?output_file ast
-          
+
       end
-      
+
     let enable_ocaml_printer () =
       let module M = OCamlPrinter(PP.OCaml.Id)(PP.OCaml.MakeMore) in ()
-      
+
     let enable_ocamlr_printer () =
       let module M = OCamlPrinter(PP.OCamlr.Id)(PP.OCamlr.MakeMore) in ()
-      
+
     let enable_dump_ocaml_ast_printer () =
       let module M = OCamlPrinter(PP.DumpOCamlAst.Id)(PP.DumpOCamlAst.Make)
       in ()
-      
+
     let enable_dump_camlp4_ast_printer () =
       let module M = Printer(PP.DumpCamlp4Ast.Id)(PP.DumpCamlp4Ast.Make)
       in ()
-      
+
     let enable_null_printer () =
       let module M = Printer(PP.Null.Id)(PP.Null.Make) in ()
-      
+
   end
-  
+
 
